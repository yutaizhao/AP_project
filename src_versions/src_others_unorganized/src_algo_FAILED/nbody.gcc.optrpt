nbody.c:63:11: note: Considering inline candidate addParticle/23.
nbody.c:63:11: missed:   Not inlining: recursive call.
nbody.c:60:31: note: Considering inline candidate createNode/22.
nbody.c:60:31: missed:   will not early inline: addParticle/23->createNode/22, call is cold and code would grow at least by 11
nbody.c:78:15: note: Considering inline candidate computeMass/24.
nbody.c:78:15: missed:   Not inlining: recursive call.
nbody.c:107:17: note: Considering inline candidate computeForce/25.
nbody.c:107:17: missed:   Not inlining: recursive call.
nbody.c:138:5: note: Considering inline candidate computeMass/24.
nbody.c:138:5: missed:   will not early inline: createTree/26->computeMass/24, growth 8 exceeds --param early-inlining-insns
nbody.c:135:9: note: Considering inline candidate addParticle/23.
nbody.c:135:9: optimized:  Inlining addParticle/23 into createTree/26.
nbody.c:131:18: note: Considering inline candidate createNode/22.
nbody.c:131:18: missed:   will not early inline: createTree/26->createNode/22, call is cold and code would grow at least by 11
nbody.c:175:7: note: Considering inline candidate computeForce/25.
nbody.c:175:7: missed:   will not early inline: move_particles/28->computeForce/25, call is cold and code would grow at least by 25
nbody.c:196:30: optimized:   Inlining atoll/13 into main/29 (always_inline).
nbody.c:233:7: note: Considering inline candidate move_particles/28.
nbody.c:233:7: missed:   will not early inline: main/29->move_particles/28, call is cold and code would grow at least by 50
nbody.c:217:16: note: Considering inline candidate createTree/26.
nbody.c:217:16: missed:   will not early inline: main/29->createTree/26, call is cold and code would grow at least by 64
nbody.c:214:3: note: Considering inline candidate init/27.
nbody.c:214:3: missed:   will not early inline: main/29->init/27, call is cold and code would grow at least by 41
nbody.c:62:4: missed:   not inlinable: addParticle.part.0/42 -> printf/31, function body not available
nbody.c:277:3: missed:   not inlinable: main/29 -> free/40, function body not available
nbody.c:276:3: missed:   not inlinable: main/29 -> free/40, function body not available
nbody.c:273:3: missed:   not inlinable: main/29 -> __builtin_puts/33, function body not available
nbody.c:271:3: missed:   not inlinable: main/29 -> printf/31, function body not available
nbody.c:270:3: missed:   not inlinable: main/29 -> __builtin_puts/33, function body not available
nbody.c:268:11: missed:   not inlinable: main/29 -> sqrt/32, function body not available
nbody.c:261:7: missed:   not inlinable: main/29 -> fflush/38, function body not available
nbody.c:254:7: missed:   not inlinable: main/29 -> printf/31, function body not available
nbody.c:235:23: missed:   not inlinable: main/29 -> omp_get_wtime/39, function body not available
nbody.c:233:7: missed:   not inlinable: main/29 -> move_particles/28, --param max-inline-insns-auto limit reached
nbody.c:231:25: missed:   not inlinable: main/29 -> omp_get_wtime/39, function body not available
nbody.c:225:92: missed:   not inlinable: main/29 -> fflush/38, function body not available
nbody.c:225:3: missed:   not inlinable: main/29 -> printf/31, function body not available
nbody.c:222:3: missed:   not inlinable: main/29 -> printf/31, function body not available
nbody.c:218:3: missed:   not inlinable: main/29 -> __builtin_puts/33, function body not available
nbody.c:217:16: missed:   not inlinable: main/29 -> createTree/26, --param max-inline-insns-auto limit reached
nbody.c:216:3: missed:   not inlinable: main/29 -> __builtin_puts/33, function body not available
nbody.c:214:3: missed:   not inlinable: main/29 -> init/27, --param max-inline-insns-auto limit reached
nbody.c:212:28: missed:   not inlinable: main/29 -> aligned_alloc/36, function body not available
/usr/include/stdlib.h:495:10: missed:   not inlinable: main/29 -> strtoll/41, function body not available
nbody.c:188:7: missed:   not inlinable: move_particles/28 -> printf/31, function body not available
nbody.c:175:7: missed:   not inlinable: move_particles/28 -> computeForce/25, --param max-inline-insns-auto limit reached
nbody.c:160:22: missed:   not inlinable: init/27 -> rand/35, function body not available
nbody.c:159:29: missed:   not inlinable: init/27 -> rand/35, function body not available
nbody.c:158:22: missed:   not inlinable: init/27 -> rand/35, function body not available
nbody.c:156:28: missed:   not inlinable: init/27 -> rand/35, function body not available
nbody.c:155:21: missed:   not inlinable: init/27 -> rand/35, function body not available
nbody.c:154:28: missed:   not inlinable: init/27 -> rand/35, function body not available
nbody.c:151:21: missed:   not inlinable: init/27 -> rand/35, function body not available
nbody.c:150:21: missed:   not inlinable: init/27 -> rand/35, function body not available
nbody.c:137:5: missed:   not inlinable: createTree/26 -> __builtin_puts/33, function body not available
missed:   not inlinable: createTree/26 -> addParticle.part.0/42, --param max-inline-insns-auto limit reached
nbody.c:134:3: missed:   not inlinable: createTree/26 -> printf/31, function body not available
nbody.c:132:5: missed:   not inlinable: createTree/26 -> __builtin_puts/33, function body not available
nbody.c:130:5: missed:   not inlinable: createTree/26 -> __builtin_puts/33, function body not available
nbody.c:126:16: missed:   not inlinable: createTree/26 -> fmax/34, function body not available
nbody.c:126:16: missed:   not inlinable: createTree/26 -> fmax/34, function body not available
nbody.c:125:5: missed:   not inlinable: createTree/26 -> __builtin_puts/33, function body not available
nbody.c:107:17: missed:   not inlinable: computeForce/25 -> computeForce/25, --param max-inline-insns-auto limit reached
nbody.c:97:24: missed:   not inlinable: computeForce/25 -> sqrt/32, function body not available
missed:   not inlinable: addParticle/23 -> addParticle.part.0/42, --param max-inline-insns-auto limit reached
nbody.c:33:16: missed:   not inlinable: createNode/22 -> malloc/30, function body not available
nbody.c:63:11: optimized:  Inlined addParticle/45 into addParticle.part.0/42 which now has time 456.155653 and size 52, net change of +3.
nbody.c:78:15: missed:   not inlinable: computeMass.part.0/43 -> computeMass/24, --param max-inline-insns-auto limit reached
nbody.c:138:5: missed:   not inlinable: createTree/26 -> computeMass/24, --param max-inline-insns-auto limit reached
optimized:  Inlined computeMass.part.0/43 into computeMass/24 which now has time 72.729348 and size 46, net change of -13.
nbody.c:60:31: optimized:  Inlined createNode/46 into addParticle.part.0/42 which now has time 523.100657 and size 63, net change of +11.
nbody.c:131:18: optimized:  Inlined createNode/47 into createTree/26 which now has time 556.031780 and size 85, net change of +11.
Unit growth for small function inlining: 481->493 (2%)

Inlined 6 calls, eliminated 1 functions

BB 9 is always executed in loop 1
BB 7 is always executed in loop 1
BB 5 is always executed in loop 1
BB 3 is always executed in loop 1
BB 11 is always executed in loop 2
loop 1's coldest_outermost_loop is 1, hotter_than_inner_loop is NULL
loop 2's coldest_outermost_loop is 1, hotter_than_inner_loop is NULL
nbody.c:39:21: optimized: Loop 2 distributed: split to 0 loops and 1 library calls.
nbody.c:33:16: missed: statement clobbers memory: node_35 = malloc (104);
nbody.c:54:25: missed: couldn't vectorize loop
nbody.c:54:25: missed: not vectorized: control flow in loop.
nbody.c:50:6: note: vectorized 0 loops in function.
nbody.c:33:16: missed: statement clobbers memory: node_35 = malloc (104);
nbody.c:33:16: missed: statement clobbers memory: node_35 = malloc (104);
nbody.c:40:21: missed: statement clobbers memory: __builtin_memset (_34, 0, 64);
nbody.c:62:4: missed: statement clobbers memory: printf ("%d \n", i_31);
nbody.c:50:6: missed: statement clobbers memory: addParticle.part.0 (_25, p_26(D));
nbody.c:42:11: note: ***** Analysis succeeded with vector mode V8SF
nbody.c:42:11: note: SLPing BB part
nbody.c:34:12: note: Costing subgraph: 
nbody.c:34:12: note: node 0x39e0958 (max_nunits=4, refcnt=1) vector(4) float
nbody.c:34:12: note: op template: node_35->cx = f_x_10;
nbody.c:34:12: note: 	stmt 0 node_35->cx = f_x_10;
nbody.c:34:12: note: 	stmt 1 node_35->cy = f_y_16;
nbody.c:34:12: note: 	stmt 2 node_35->cz = f_z_22;
nbody.c:34:12: note: 	stmt 3 node_35->size = f_size_3;
nbody.c:34:12: note: 	children 0x39e0a58
nbody.c:34:12: note: node (external) 0x39e0a58 (max_nunits=1, refcnt=1) vector(4) float
nbody.c:34:12: note: 	{ f_x_10, f_y_16, f_z_22, f_size_3 }
nbody.c:34:12: note: Cost model analysis: 
nbody.c:34:12: note: Cost model analysis for part in loop 1:
  Vector cost: 24
  Scalar cost: 48
nbody.c:42:11: note: Costing subgraph: 
nbody.c:42:11: note: node 0x39e0ad8 (max_nunits=4, refcnt=1) vector(4) float
nbody.c:42:11: note: op template: node_35->m = 0.0;
nbody.c:42:11: note: 	stmt 0 node_35->m = 0.0;
nbody.c:42:11: note: 	stmt 1 node_35->cmx = 0.0;
nbody.c:42:11: note: 	stmt 2 node_35->cmy = 0.0;
nbody.c:42:11: note: 	stmt 3 node_35->cmz = 0.0;
nbody.c:42:11: note: 	children 0x39e0b58
nbody.c:42:11: note: node (constant) 0x39e0b58 (max_nunits=1, refcnt=1) vector(4) float
nbody.c:42:11: note: 	{ 0.0, 0.0, 0.0, 0.0 }
nbody.c:42:11: note: Cost model analysis: 
nbody.c:42:11: note: Cost model analysis for part in loop 1:
  Vector cost: 24
  Scalar cost: 48
nbody.c:42:11: note: Basic block will be vectorized using SLP
nbody.c:42:11: note: Vectorizing SLP tree:
nbody.c:42:11: note: node 0x39e0958 (max_nunits=4, refcnt=1) vector(4) float
nbody.c:42:11: note: op template: node_35->cx = f_x_10;
nbody.c:42:11: note: 	stmt 0 node_35->cx = f_x_10;
nbody.c:42:11: note: 	stmt 1 node_35->cy = f_y_16;
nbody.c:42:11: note: 	stmt 2 node_35->cz = f_z_22;
nbody.c:42:11: note: 	stmt 3 node_35->size = f_size_3;
nbody.c:42:11: note: 	children 0x39e0a58
nbody.c:42:11: note: node (external) 0x39e0a58 (max_nunits=1, refcnt=1) vector(4) float
nbody.c:42:11: note: 	{ f_x_10, f_y_16, f_z_22, f_size_3 }
nbody.c:42:11: note: ------>vectorizing SLP node starting from: node_35->cx = f_x_10;
nbody.c:42:11: note: vect_is_simple_use: operand _11 + _15, type of def: internal
nbody.c:42:11: note: vect_is_simple_use: operand _17 + _21, type of def: internal
nbody.c:42:11: note: vect_is_simple_use: operand _2 * 5.0e-1, type of def: internal
nbody.c:42:11: note: transform store. ncopies = 1
nbody.c:42:11: note: create vector_type-pointer variable to type: vector(4) float  vectorizing a pointer ref: node_35->cx
nbody.c:42:11: note: created vectp.25_40
nbody.c:42:11: note: add new stmt: MEM <vector(4) float> [(float *)vectp.25_40] = _57;
nbody.c:42:11: note: vectorizing stmts using SLP.
nbody.c:42:11: optimized: basic block part vectorized using 32 byte vectors
nbody.c:42:11: note: Vectorizing SLP tree:
nbody.c:42:11: note: node 0x39e0ad8 (max_nunits=4, refcnt=1) vector(4) float
nbody.c:42:11: note: op template: node_35->m = 0.0;
nbody.c:42:11: note: 	stmt 0 node_35->m = 0.0;
nbody.c:42:11: note: 	stmt 1 node_35->cmx = 0.0;
nbody.c:42:11: note: 	stmt 2 node_35->cmy = 0.0;
nbody.c:42:11: note: 	stmt 3 node_35->cmz = 0.0;
nbody.c:42:11: note: 	children 0x39e0b58
nbody.c:42:11: note: node (constant) 0x39e0b58 (max_nunits=1, refcnt=1) vector(4) float
nbody.c:42:11: note: 	{ 0.0, 0.0, 0.0, 0.0 }
nbody.c:42:11: note: ------>vectorizing SLP node starting from: node_35->m = 0.0;
nbody.c:42:11: note: vect_is_simple_use: operand 0.0, type of def: constant
nbody.c:42:11: note: vect_is_simple_use: operand 0.0, type of def: constant
nbody.c:42:11: note: vect_is_simple_use: operand 0.0, type of def: constant
nbody.c:42:11: note: transform store. ncopies = 1
nbody.c:42:11: note: create vector_type-pointer variable to type: vector(4) float  vectorizing a pointer ref: node_35->m
nbody.c:42:11: note: created vectp.27_58
nbody.c:42:11: note: add new stmt: MEM <vector(4) float> [(float *)vectp.27_58] = { 0.0, 0.0, 0.0, 0.0 };
nbody.c:42:11: note: vectorizing stmts using SLP.
nbody.c:42:11: optimized: basic block part vectorized using 32 byte vectors
nbody.c:42:11: note: ***** The result for vector mode V32QI would be the same
BB 9 is always executed in loop 1
BB 7 is always executed in loop 1
BB 5 is always executed in loop 1
BB 3 is always executed in loop 1
loop 1's coldest_outermost_loop is 1, hotter_than_inner_loop is NULL
nbody.c:54:25: note: considering unrolling loop 1 at BB 3
considering unrolling loop with constant number of iterations
considering unrolling loop with runtime-computable number of iterations
BB 3 is always executed in loop 1
loop 1's coldest_outermost_loop is 1, hotter_than_inner_loop is NULL
nbody.c:39:21: optimized: Loop 1 distributed: split to 0 loops and 1 library calls.
nbody.c:32:7: note: vectorized 0 loops in function.
nbody.c:33:16: missed: statement clobbers memory: node_5 = malloc (104);
nbody.c:40:21: missed: statement clobbers memory: __builtin_memset (_22, 0, 64);
nbody.c:42:11: note: ***** Analysis succeeded with vector mode V8SF
nbody.c:42:11: note: SLPing BB part
nbody.c:34:12: note: Costing subgraph: 
nbody.c:34:12: note: node 0x39e0958 (max_nunits=4, refcnt=1) vector(4) float
nbody.c:34:12: note: op template: node_5->cx = x_6(D);
nbody.c:34:12: note: 	stmt 0 node_5->cx = x_6(D);
nbody.c:34:12: note: 	stmt 1 node_5->cy = y_8(D);
nbody.c:34:12: note: 	stmt 2 node_5->cz = z_10(D);
nbody.c:34:12: note: 	stmt 3 node_5->size = size_12(D);
nbody.c:34:12: note: 	children 0x39e09d8
nbody.c:34:12: note: node (external) 0x39e09d8 (max_nunits=1, refcnt=1) vector(4) float
nbody.c:34:12: note: 	{ x_6(D), y_8(D), z_10(D), size_12(D) }
nbody.c:34:12: note: Cost model analysis: 
nbody.c:34:12: note: Cost model analysis for part in loop 0:
  Vector cost: 24
  Scalar cost: 48
nbody.c:42:11: note: Costing subgraph: 
nbody.c:42:11: note: node 0x39e0a58 (max_nunits=4, refcnt=1) vector(4) float
nbody.c:42:11: note: op template: node_5->m = 0.0;
nbody.c:42:11: note: 	stmt 0 node_5->m = 0.0;
nbody.c:42:11: note: 	stmt 1 node_5->cmx = 0.0;
nbody.c:42:11: note: 	stmt 2 node_5->cmy = 0.0;
nbody.c:42:11: note: 	stmt 3 node_5->cmz = 0.0;
nbody.c:42:11: note: 	children 0x39e0ad8
nbody.c:42:11: note: node (constant) 0x39e0ad8 (max_nunits=1, refcnt=1) vector(4) float
nbody.c:42:11: note: 	{ 0.0, 0.0, 0.0, 0.0 }
nbody.c:42:11: note: Cost model analysis: 
nbody.c:42:11: note: Cost model analysis for part in loop 0:
  Vector cost: 24
  Scalar cost: 48
nbody.c:42:11: note: Basic block will be vectorized using SLP
nbody.c:42:11: note: Vectorizing SLP tree:
nbody.c:42:11: note: node 0x39e0958 (max_nunits=4, refcnt=1) vector(4) float
nbody.c:42:11: note: op template: node_5->cx = x_6(D);
nbody.c:42:11: note: 	stmt 0 node_5->cx = x_6(D);
nbody.c:42:11: note: 	stmt 1 node_5->cy = y_8(D);
nbody.c:42:11: note: 	stmt 2 node_5->cz = z_10(D);
nbody.c:42:11: note: 	stmt 3 node_5->size = size_12(D);
nbody.c:42:11: note: 	children 0x39e09d8
nbody.c:42:11: note: node (external) 0x39e09d8 (max_nunits=1, refcnt=1) vector(4) float
nbody.c:42:11: note: 	{ x_6(D), y_8(D), z_10(D), size_12(D) }
nbody.c:42:11: note: ------>vectorizing SLP node starting from: node_5->cx = x_6(D);
nbody.c:42:11: note: vect_is_simple_use: operand y_8(D), type of def: external
nbody.c:42:11: note: vect_is_simple_use: operand z_10(D), type of def: external
nbody.c:42:11: note: vect_is_simple_use: operand size_12(D), type of def: external
nbody.c:42:11: note: transform store. ncopies = 1
nbody.c:42:11: note: create vector_type-pointer variable to type: vector(4) float  vectorizing a pointer ref: node_5->cx
nbody.c:42:11: note: created vectp.43_2
nbody.c:42:11: note: add new stmt: MEM <vector(4) float> [(float *)vectp.43_2] = _25;
nbody.c:42:11: note: vectorizing stmts using SLP.
nbody.c:42:11: optimized: basic block part vectorized using 32 byte vectors
nbody.c:42:11: note: Vectorizing SLP tree:
nbody.c:42:11: note: node 0x39e0a58 (max_nunits=4, refcnt=1) vector(4) float
nbody.c:42:11: note: op template: node_5->m = 0.0;
nbody.c:42:11: note: 	stmt 0 node_5->m = 0.0;
nbody.c:42:11: note: 	stmt 1 node_5->cmx = 0.0;
nbody.c:42:11: note: 	stmt 2 node_5->cmy = 0.0;
nbody.c:42:11: note: 	stmt 3 node_5->cmz = 0.0;
nbody.c:42:11: note: 	children 0x39e0ad8
nbody.c:42:11: note: node (constant) 0x39e0ad8 (max_nunits=1, refcnt=1) vector(4) float
nbody.c:42:11: note: 	{ 0.0, 0.0, 0.0, 0.0 }
nbody.c:42:11: note: ------>vectorizing SLP node starting from: node_5->m = 0.0;
nbody.c:42:11: note: vect_is_simple_use: operand 0.0, type of def: constant
nbody.c:42:11: note: vect_is_simple_use: operand 0.0, type of def: constant
nbody.c:42:11: note: vect_is_simple_use: operand 0.0, type of def: constant
nbody.c:42:11: note: transform store. ncopies = 1
nbody.c:42:11: note: create vector_type-pointer variable to type: vector(4) float  vectorizing a pointer ref: node_5->m
nbody.c:42:11: note: created vectp.45_23
nbody.c:42:11: note: add new stmt: MEM <vector(4) float> [(float *)vectp.45_23] = { 0.0, 0.0, 0.0, 0.0 };
nbody.c:42:11: note: vectorizing stmts using SLP.
nbody.c:42:11: optimized: basic block part vectorized using 32 byte vectors
nbody.c:42:11: note: ***** The result for vector mode V32QI would be the same
nbody.c:50:6: note: vectorized 0 loops in function.
nbody.c:50:6: missed: statement clobbers memory: addParticle.part.0 (node_5(D), p_8(D));
nbody.c:66:1: note: ***** Analysis failed with vector mode V4DI
nbody.c:66:1: note: ***** Skipping vector mode V32QI, which would repeat the analysis for V4DI
BB 4 is always executed in loop 2
loop 2's coldest_outermost_loop is 2, hotter_than_inner_loop is NULL
nbody.c:74:17: optimized: sinking common stores to node_10(D)->cmz
nbody.c:78:15: missed: statement clobbers memory: computeMass (_16);
nbody.c:76:25: missed: couldn't vectorize loop
nbody.c:76:25: missed: not vectorized: control flow in loop.
nbody.c:69:6: note: vectorized 0 loops in function.
nbody.c:78:15: missed: statement clobbers memory: computeMass (_16);
nbody.c:78:15: missed: statement clobbers memory: computeMass (_16);
nbody.c:85:17: note: ***** Analysis succeeded with vector mode V4DI
nbody.c:85:17: note: SLPing BB part
nbody.c:85:17: note: Costing subgraph: 
nbody.c:85:17: note: node 0x3a72a38 (max_nunits=2, refcnt=1) vector(2) float
nbody.c:85:17: note: op template: node_10(D)->cmx = _37;
nbody.c:85:17: note: 	stmt 0 node_10(D)->cmx = _37;
nbody.c:85:17: note: 	stmt 1 node_10(D)->cmy = _39;
nbody.c:85:17: note: 	children 0x3a72ab8
nbody.c:85:17: note: node 0x3a72ab8 (max_nunits=2, refcnt=1) vector(2) float
nbody.c:85:17: note: op template: _37 = _35 / _36;
nbody.c:85:17: note: 	stmt 0 _37 = _35 / _36;
nbody.c:85:17: note: 	stmt 1 _39 = _38 / _36;
nbody.c:85:17: note: 	children 0x3a72b38 0x3a72bb8
nbody.c:85:17: note: node 0x3a72b38 (max_nunits=2, refcnt=1) vector(2) float
nbody.c:85:17: note: op template: _35 = node_10(D)->cmx;
nbody.c:85:17: note: 	stmt 0 _35 = node_10(D)->cmx;
nbody.c:85:17: note: 	stmt 1 _38 = node_10(D)->cmy;
nbody.c:85:17: note: node 0x3a72bb8 (max_nunits=2, refcnt=1) vector(2) float
nbody.c:85:17: note: op template: _36 = node_10(D)->m;
nbody.c:85:17: note: 	stmt 0 _36 = node_10(D)->m;
nbody.c:85:17: note: 	stmt 1 _36 = node_10(D)->m;
nbody.c:85:17: note: 	load permutation { 0 0 }
nbody.c:85:17: note: Cost model analysis: 
nbody.c:85:17: note: Cost model analysis for part in loop 0:
  Vector cost: 120
  Scalar cost: 204
nbody.c:85:17: note: Basic block will be vectorized using SLP
nbody.c:85:17: note: Vectorizing SLP tree:
nbody.c:85:17: note: node 0x3a72a38 (max_nunits=2, refcnt=1) vector(2) float
nbody.c:85:17: note: op template: node_10(D)->cmx = _37;
nbody.c:85:17: note: 	stmt 0 node_10(D)->cmx = _37;
nbody.c:85:17: note: 	stmt 1 node_10(D)->cmy = _39;
nbody.c:85:17: note: 	children 0x3a72ab8
nbody.c:85:17: note: node 0x3a72ab8 (max_nunits=2, refcnt=1) vector(2) float
nbody.c:85:17: note: op template: _37 = _35 / _36;
nbody.c:85:17: note: 	stmt 0 _37 = _35 / _36;
nbody.c:85:17: note: 	stmt 1 _39 = _38 / _36;
nbody.c:85:17: note: 	children 0x3a72b38 0x3a72bb8
nbody.c:85:17: note: node 0x3a72b38 (max_nunits=2, refcnt=1) vector(2) float
nbody.c:85:17: note: op template: _35 = node_10(D)->cmx;
nbody.c:85:17: note: 	stmt 0 _35 = node_10(D)->cmx;
nbody.c:85:17: note: 	stmt 1 _38 = node_10(D)->cmy;
nbody.c:85:17: note: node 0x3a72bb8 (max_nunits=2, refcnt=1) vector(2) float
nbody.c:85:17: note: op template: _36 = node_10(D)->m;
nbody.c:85:17: note: 	stmt 0 _36 = node_10(D)->m;
nbody.c:85:17: note: 	stmt 1 _36 = node_10(D)->m;
nbody.c:85:17: note: 	load permutation { 0 0 }
nbody.c:85:17: note: ------>vectorizing SLP node starting from: _35 = node_10(D)->cmx;
nbody.c:85:17: note: transform load. ncopies = 1
nbody.c:85:17: note: create vector_type-pointer variable to type: vector(2) float  vectorizing a pointer ref: node_10(D)->cmx
nbody.c:85:17: note: created vectp.54_15
nbody.c:85:17: note: add new stmt: vect__35.55_8 = MEM <vector(2) float> [(float *)vectp.54_15];
nbody.c:85:17: note: add new stmt: vectp.54_53 = vectp.54_15 + 8;
nbody.c:85:17: note: ------>vectorizing SLP node starting from: _36 = node_10(D)->m;
nbody.c:85:17: note: transform load. ncopies = 1
nbody.c:85:17: note: create vector_type-pointer variable to type: vector(2) float  vectorizing a pointer ref: node_10(D)->m
nbody.c:85:17: note: created vectp.57_54
nbody.c:85:17: note: add new stmt: vect__36.58_55 = MEM <vector(2) float> [(float *)vectp.57_54];
nbody.c:85:17: note: add new stmt: vectp.57_56 = vectp.57_54 + 8;
nbody.c:85:17: note: add new stmt: vect__36.59_57 = MEM <vector(2) float> [(float *)vectp.57_56];
nbody.c:85:17: note: add new stmt: vect__36.60_58 = VEC_PERM_EXPR <vect__36.58_55, vect__36.58_55, { 0, 0 }>;
nbody.c:85:17: note: extracting lane for live stmt _36 = node_10(D)->m;
nbody.c:85:17: note: extracting lane for live stmt _36 = node_10(D)->m;
nbody.c:85:17: note: ------>vectorizing SLP node starting from: _37 = _35 / _36;
nbody.c:85:17: note: vect_is_simple_use: operand node_10(D)->cmx, type of def: internal
nbody.c:85:17: note: vect_is_simple_use: operand node_10(D)->m, type of def: internal
nbody.c:85:17: note: transform binary/unary operation.
nbody.c:85:17: note: add new stmt: vect__37.61_61 = vect__35.55_8 / vect__36.60_58;
nbody.c:85:17: note: ------>vectorizing SLP node starting from: node_10(D)->cmx = _37;
nbody.c:85:17: note: vect_is_simple_use: operand _35 / _36, type of def: internal
nbody.c:85:17: note: vect_is_simple_use: operand _38 / _36, type of def: internal
nbody.c:85:17: note: transform store. ncopies = 1
nbody.c:85:17: note: create vector_type-pointer variable to type: vector(2) float  vectorizing a pointer ref: node_10(D)->cmx
nbody.c:85:17: note: created vectp.63_62
nbody.c:85:17: note: add new stmt: MEM <vector(2) float> [(float *)vectp.63_62] = vect__37.61_61;
nbody.c:85:17: note: vectorizing stmts using SLP.
nbody.c:85:17: optimized: basic block part vectorized using 32 byte vectors
nbody.c:85:17: note: ***** The result for vector mode V32QI would be the same
BB 4 is always executed in loop 2
loop 2's coldest_outermost_loop is 2, hotter_than_inner_loop is NULL
nbody.c:76:25: note: considering unrolling loop 2 at BB 5
considering unrolling loop with constant number of iterations
considering unrolling loop with runtime-computable number of iterations
nbody.c:97:24: missed: statement clobbers memory: _55 = sqrt (_13);
BB 7 is always executed in loop 1
loop 1's coldest_outermost_loop is 1, hotter_than_inner_loop is NULL
nbody.c:107:17: missed: statement clobbers memory: computeForce (_30, p_37(D), theta_43(D), fx_44(D), fy_45(D), fz_46(D));
nbody.c:105:27: missed: couldn't vectorize loop
nbody.c:105:27: missed: not vectorized: control flow in loop.
nbody.c:92:6: note: vectorized 0 loops in function.
nbody.c:107:17: missed: statement clobbers memory: computeForce (_30, p_37(D), theta_43(D), fx_44(D), fy_45(D), fz_46(D));
nbody.c:97:24: missed: statement clobbers memory: _55 = sqrt (_13);
nbody.c:107:17: missed: statement clobbers memory: computeForce (_30, p_37(D), theta_43(D), fx_44(D), fy_45(D), fz_46(D));
nbody.c:111:1: note: ***** Analysis failed with vector mode V8SF
nbody.c:111:1: note: ***** Skipping vector mode V32QI, which would repeat the analysis for V8SF
BB 7 is always executed in loop 1
loop 1's coldest_outermost_loop is 1, hotter_than_inner_loop is NULL
nbody.c:105:27: note: considering unrolling loop 1 at BB 8
considering unrolling loop with constant number of iterations
considering unrolling loop with runtime-computable number of iterations
BB 19 is always executed in loop 2
BB 17 is always executed in loop 3
BB 15 is always executed in loop 1
BB 13 is always executed in loop 1
BB 11 is always executed in loop 1
BB 9 is always executed in loop 1
BB 7 is always executed in loop 1
BB 5 is always executed in loop 1
BB 3 is always executed in loop 1
loop 2's coldest_outermost_loop is 2, hotter_than_inner_loop is NULL
loop 3's coldest_outermost_loop is 3, hotter_than_inner_loop is NULL
loop 1's coldest_outermost_loop is 1, hotter_than_inner_loop is NULL
nbody.c:39:21: optimized: Loop 3 distributed: split to 0 loops and 1 library calls.
nbody.c:134:3: missed: statement clobbers memory: printf ("ADDING ,,,,,,,,,, %d \n", i_98);
nbody.c:133:23: missed: couldn't vectorize loop
nbody.c:133:23: missed: not vectorized: control flow in loop.
nbody.c:117:23: missed: couldn't vectorize loop
nbody.c:113:7: missed: not vectorized: unsupported use in stmt.
nbody.c:117:23: note: ***** Analysis failed with vector mode V8SF
nbody.c:117:23: note: ***** Skipping vector mode V32QI, which would repeat the analysis for V8SF
nbody.c:113:7: note: vectorized 0 loops in function.
nbody.c:134:3: missed: statement clobbers memory: printf ("ADDING ,,,,,,,,,, %d \n", i_98);
nbody.c:125:5: missed: statement clobbers memory: __builtin_puts (&"loop 1"[0]);
nbody.c:130:5: missed: statement clobbers memory: __builtin_puts (&"bf create node "[0]);
nbody.c:33:16: missed: statement clobbers memory: node_65 = malloc (104);
nbody.c:40:21: missed: statement clobbers memory: __builtin_memset (_30, 0, 64);
nbody.c:132:5: missed: statement clobbers memory: __builtin_puts (&"afteer create node "[0]);
nbody.c:134:3: missed: statement clobbers memory: printf ("ADDING ,,,,,,,,,, %d \n", i_98);
nbody.c:113:7: missed: statement clobbers memory: addParticle.part.0 (node_65, _21);
nbody.c:137:5: missed: statement clobbers memory: __builtin_puts (&"loop2"[0]);
nbody.c:138:5: missed: statement clobbers memory: computeMass (node_65);
nbody.c:42:11: note: ***** Analysis succeeded with vector mode V8SF
nbody.c:42:11: note: SLPing BB part
nbody.c:34:12: note: Costing subgraph: 
nbody.c:34:12: note: node 0x3b55698 (max_nunits=4, refcnt=1) vector(4) float
nbody.c:34:12: note: op template: *node_65.cx = x_49;
nbody.c:34:12: note: 	stmt 0 *node_65.cx = x_49;
nbody.c:34:12: note: 	stmt 1 *node_65.cy = y_50;
nbody.c:34:12: note: 	stmt 2 *node_65.cz = z_51;
nbody.c:34:12: note: 	stmt 3 *node_65.size = size_48;
nbody.c:34:12: note: 	children 0x3b55798
nbody.c:34:12: note: node (external) 0x3b55798 (max_nunits=1, refcnt=1) vector(4) float
nbody.c:34:12: note: 	{ x_49, y_50, z_51, size_48 }
nbody.c:34:12: note: Cost model analysis: 
nbody.c:34:12: note: Cost model analysis for part in loop 0:
  Vector cost: 24
  Scalar cost: 48
nbody.c:42:11: note: Costing subgraph: 
nbody.c:42:11: note: node 0x3b55818 (max_nunits=4, refcnt=1) vector(4) float
nbody.c:42:11: note: op template: *node_65.m = 0.0;
nbody.c:42:11: note: 	stmt 0 *node_65.m = 0.0;
nbody.c:42:11: note: 	stmt 1 *node_65.cmx = 0.0;
nbody.c:42:11: note: 	stmt 2 *node_65.cmy = 0.0;
nbody.c:42:11: note: 	stmt 3 *node_65.cmz = 0.0;
nbody.c:42:11: note: 	children 0x3b55898
nbody.c:42:11: note: node (constant) 0x3b55898 (max_nunits=1, refcnt=1) vector(4) float
nbody.c:42:11: note: 	{ 0.0, 0.0, 0.0, 0.0 }
nbody.c:42:11: note: Cost model analysis: 
nbody.c:42:11: note: Cost model analysis for part in loop 0:
  Vector cost: 24
  Scalar cost: 48
nbody.c:42:11: note: Basic block will be vectorized using SLP
nbody.c:42:11: note: Vectorizing SLP tree:
nbody.c:42:11: note: node 0x3b55698 (max_nunits=4, refcnt=1) vector(4) float
nbody.c:42:11: note: op template: *node_65.cx = x_49;
nbody.c:42:11: note: 	stmt 0 *node_65.cx = x_49;
nbody.c:42:11: note: 	stmt 1 *node_65.cy = y_50;
nbody.c:42:11: note: 	stmt 2 *node_65.cz = z_51;
nbody.c:42:11: note: 	stmt 3 *node_65.size = size_48;
nbody.c:42:11: note: 	children 0x3b55798
nbody.c:42:11: note: node (external) 0x3b55798 (max_nunits=1, refcnt=1) vector(4) float
nbody.c:42:11: note: 	{ x_49, y_50, z_51, size_48 }
nbody.c:42:11: note: ------>vectorizing SLP node starting from: *node_65.cx = x_49;
nbody.c:42:11: note: vect_is_simple_use: operand _17 * 5.0e-1, type of def: internal
nbody.c:42:11: note: vect_is_simple_use: operand _18 * 5.0e-1, type of def: internal
nbody.c:42:11: note: vect_is_simple_use: operand (f32) _15, type of def: internal
nbody.c:42:11: note: transform store. ncopies = 1
nbody.c:42:11: note: create vector_type-pointer variable to type: vector(4) float  vectorizing a pointer ref: *node_65.cx
nbody.c:42:11: note: created vectp.96_97
nbody.c:42:11: note: add new stmt: MEM <vector(4) float> [(float *)vectp.96_97] = _32;
nbody.c:42:11: note: vectorizing stmts using SLP.
nbody.c:42:11: optimized: basic block part vectorized using 32 byte vectors
nbody.c:42:11: note: Vectorizing SLP tree:
nbody.c:42:11: note: node 0x3b55818 (max_nunits=4, refcnt=1) vector(4) float
nbody.c:42:11: note: op template: *node_65.m = 0.0;
nbody.c:42:11: note: 	stmt 0 *node_65.m = 0.0;
nbody.c:42:11: note: 	stmt 1 *node_65.cmx = 0.0;
nbody.c:42:11: note: 	stmt 2 *node_65.cmy = 0.0;
nbody.c:42:11: note: 	stmt 3 *node_65.cmz = 0.0;
nbody.c:42:11: note: 	children 0x3b55898
nbody.c:42:11: note: node (constant) 0x3b55898 (max_nunits=1, refcnt=1) vector(4) float
nbody.c:42:11: note: 	{ 0.0, 0.0, 0.0, 0.0 }
nbody.c:42:11: note: ------>vectorizing SLP node starting from: *node_65.m = 0.0;
nbody.c:42:11: note: vect_is_simple_use: operand 0.0, type of def: constant
nbody.c:42:11: note: vect_is_simple_use: operand 0.0, type of def: constant
nbody.c:42:11: note: vect_is_simple_use: operand 0.0, type of def: constant
nbody.c:42:11: note: transform store. ncopies = 1
nbody.c:42:11: note: create vector_type-pointer variable to type: vector(4) float  vectorizing a pointer ref: *node_65.m
nbody.c:42:11: note: created vectp.98_93
nbody.c:42:11: note: add new stmt: MEM <vector(4) float> [(float *)vectp.98_93] = { 0.0, 0.0, 0.0, 0.0 };
nbody.c:42:11: note: vectorizing stmts using SLP.
nbody.c:42:11: optimized: basic block part vectorized using 32 byte vectors
nbody.c:42:11: note: ***** The result for vector mode V32QI would be the same
BB 19 is always executed in loop 2
BB 43 is always executed in loop 4
BB 41 is always executed in loop 4
BB 39 is always executed in loop 4
BB 37 is always executed in loop 4
BB 35 is always executed in loop 4
BB 33 is always executed in loop 4
BB 31 is always executed in loop 4
loop 2's coldest_outermost_loop is 2, hotter_than_inner_loop is NULL
loop 4's coldest_outermost_loop is 4, hotter_than_inner_loop is NULL
nbody.c:133:23: note: considering unrolling loop 2 at BB 9
considering unrolling loop with constant number of iterations
considering unrolling loop with runtime-computable number of iterations
nbody.c:117:23: note: considering unrolling loop 4 at BB 4
considering unrolling loop with constant number of iterations
considering unrolling loop with runtime-computable number of iterations
BB 3 is always executed in loop 1
loop 1's coldest_outermost_loop is 1, hotter_than_inner_loop is NULL
nbody.c:150:21: missed: statement clobbers memory: _1 = rand ();
nbody.c:147:21: missed: couldn't vectorize loop
nbody.c:147:21: missed: not vectorized: control flow in loop.
nbody.c:145:6: note: vectorized 0 loops in function.
nbody.c:150:21: missed: statement clobbers memory: _1 = rand ();
nbody.c:150:21: missed: statement clobbers memory: _1 = rand ();
nbody.c:151:21: missed: statement clobbers memory: _2 = rand ();
nbody.c:154:28: missed: statement clobbers memory: _3 = rand ();
nbody.c:155:21: missed: statement clobbers memory: _9 = rand ();
nbody.c:156:28: missed: statement clobbers memory: _12 = rand ();
nbody.c:158:22: missed: statement clobbers memory: _16 = rand ();
nbody.c:159:29: missed: statement clobbers memory: _19 = rand ();
nbody.c:160:22: missed: statement clobbers memory: _23 = rand ();
nbody.c:163:1: note: ***** Analysis failed with vector mode V8SF
nbody.c:163:1: note: ***** Skipping vector mode V32QI, which would repeat the analysis for V8SF
BB 3 is always executed in loop 1
loop 1's coldest_outermost_loop is 1, hotter_than_inner_loop is NULL
nbody.c:147:21: note: considering unrolling loop 1 at BB 4
considering unrolling loop with constant number of iterations
considering unrolling loop with runtime-computable number of iterations
BB 4 is always executed in loop 2
BB 3 is always executed in loop 1
loop 2's coldest_outermost_loop is 2, hotter_than_inner_loop is NULL
loop 1's coldest_outermost_loop is 1, hotter_than_inner_loop is NULL
nbody.c:188:7: missed: statement clobbers memory: printf ("%f %f %f\n", _31, _30, _29);
nbody.c:175:7: missed: statement clobbers memory: computeForce (root_48(D), _2, 5.0e-1, &fx, &fy, &fz);
nbody.c:183:21: missed: couldn't vectorize loop
nbody.c:188:7: missed: statement clobbers memory: printf ("%f %f %f\n", _31, _30, _29);
nbody.c:170:23: missed: couldn't vectorize loop
nbody.c:175:7: missed: statement clobbers memory: computeForce (root_48(D), _2, 5.0e-1, &fx, &fy, &fz);
nbody.c:166:6: note: vectorized 0 loops in function.
nbody.c:175:7: missed: statement clobbers memory: computeForce (root_48(D), _2, 5.0e-1, &fx, &fy, &fz);
nbody.c:188:7: missed: statement clobbers memory: printf ("%f %f %f\n", _31, _30, _29);
nbody.c:175:7: missed: statement clobbers memory: computeForce (root_48(D), _2, 5.0e-1, &fx, &fy, &fz);
nbody.c:188:7: missed: statement clobbers memory: printf ("%f %f %f\n", _31, _30, _29);
nbody.c:185:14: note: ***** Analysis succeeded with vector mode V8SF
nbody.c:185:14: note: SLPing BB part
nbody.c:177:15: note: Costing subgraph: 
nbody.c:177:15: note: node 0x3bc7e68 (max_nunits=2, refcnt=1) vector(2) float
nbody.c:177:15: note: op template: *_2.vx = _6;
nbody.c:177:15: note: 	stmt 0 *_2.vx = _6;
nbody.c:177:15: note: 	stmt 1 *_2.vy = _10;
nbody.c:177:15: note: 	children 0x3bc7ee8
nbody.c:177:15: note: node 0x3bc7ee8 (max_nunits=2, refcnt=1) vector(2) float
nbody.c:177:15: note: op template: _6 = _3 + _5;
nbody.c:177:15: note: 	stmt 0 _6 = _3 + _5;
nbody.c:177:15: note: 	stmt 1 _10 = _7 + _9;
nbody.c:177:15: note: 	children 0x3bc7f68 0x3bc7fe8
nbody.c:177:15: note: node 0x3bc7f68 (max_nunits=2, refcnt=1) vector(2) float
nbody.c:177:15: note: op template: _3 = *_2.vx;
nbody.c:177:15: note: 	stmt 0 _3 = *_2.vx;
nbody.c:177:15: note: 	stmt 1 _7 = *_2.vy;
nbody.c:177:15: note: node 0x3bc7fe8 (max_nunits=2, refcnt=1) vector(2) float
nbody.c:177:15: note: op template: _5 = fx.4_4 * dt_39(D);
nbody.c:177:15: note: 	stmt 0 _5 = fx.4_4 * dt_39(D);
nbody.c:177:15: note: 	stmt 1 _9 = fy.5_8 * dt_39(D);
nbody.c:177:15: note: 	children 0x3bc80e8 0x3bc8168
nbody.c:177:15: note: node (external) 0x3bc80e8 (max_nunits=1, refcnt=1) vector(2) float
nbody.c:177:15: note: 	{ fx.4_4, fy.5_8 }
nbody.c:177:15: note: node (external) 0x3bc8168 (max_nunits=1, refcnt=1) vector(2) float
nbody.c:177:15: note: 	{ dt_39(D), dt_39(D) }
nbody.c:177:15: note: Cost model analysis: 
nbody.c:177:15: note: Cost model analysis for part in loop 1:
  Vector cost: 60
  Scalar cost: 104
nbody.c:185:14: note: Costing subgraph: 
nbody.c:185:14: note: node 0x3bc8268 (max_nunits=2, refcnt=1) vector(2) float
nbody.c:185:14: note: op template: *_16.x = _20;
nbody.c:185:14: note: 	stmt 0 *_16.x = _20;
nbody.c:185:14: note: 	stmt 1 *_16.y = _24;
nbody.c:185:14: note: 	children 0x3bc82e8
nbody.c:185:14: note: node 0x3bc82e8 (max_nunits=2, refcnt=1) vector(2) float
nbody.c:185:14: note: op template: _20 = _17 + _19;
nbody.c:185:14: note: 	stmt 0 _20 = _17 + _19;
nbody.c:185:14: note: 	stmt 1 _24 = _21 + _23;
nbody.c:185:14: note: 	children 0x3bc8368 0x3bc83e8
nbody.c:185:14: note: node 0x3bc8368 (max_nunits=2, refcnt=1) vector(2) float
nbody.c:185:14: note: op template: _17 = *_16.x;
nbody.c:185:14: note: 	stmt 0 _17 = *_16.x;
nbody.c:185:14: note: 	stmt 1 _21 = *_16.y;
nbody.c:185:14: note: node 0x3bc83e8 (max_nunits=2, refcnt=1) vector(2) float
nbody.c:185:14: note: op template: _19 = _18 * dt_39(D);
nbody.c:185:14: note: 	stmt 0 _19 = _18 * dt_39(D);
nbody.c:185:14: note: 	stmt 1 _23 = _22 * dt_39(D);
nbody.c:185:14: note: 	children 0x3bc8468 0x3bc84e8
nbody.c:185:14: note: node 0x3bc8468 (max_nunits=2, refcnt=1) vector(2) float
nbody.c:185:14: note: op template: _18 = *_16.vx;
nbody.c:185:14: note: 	stmt 0 _18 = *_16.vx;
nbody.c:185:14: note: 	stmt 1 _22 = *_16.vy;
nbody.c:185:14: note: node (external) 0x3bc84e8 (max_nunits=1, refcnt=1) vector(2) float
nbody.c:185:14: note: 	{ dt_39(D), dt_39(D) }
nbody.c:185:14: note: Cost model analysis: 
nbody.c:185:14: note: Cost model analysis for part in loop 2:
  Vector cost: 76
  Scalar cost: 128
nbody.c:185:14: note: Basic block will be vectorized using SLP
nbody.c:185:14: note: Vectorizing SLP tree:
nbody.c:185:14: note: node 0x3bc7e68 (max_nunits=2, refcnt=1) vector(2) float
nbody.c:185:14: note: op template: *_2.vx = _6;
nbody.c:185:14: note: 	stmt 0 *_2.vx = _6;
nbody.c:185:14: note: 	stmt 1 *_2.vy = _10;
nbody.c:185:14: note: 	children 0x3bc7ee8
nbody.c:185:14: note: node 0x3bc7ee8 (max_nunits=2, refcnt=1) vector(2) float
nbody.c:185:14: note: op template: _6 = _3 + _5;
nbody.c:185:14: note: 	stmt 0 _6 = _3 + _5;
nbody.c:185:14: note: 	stmt 1 _10 = _7 + _9;
nbody.c:185:14: note: 	children 0x3bc7f68 0x3bc7fe8
nbody.c:185:14: note: node 0x3bc7f68 (max_nunits=2, refcnt=1) vector(2) float
nbody.c:185:14: note: op template: _3 = *_2.vx;
nbody.c:185:14: note: 	stmt 0 _3 = *_2.vx;
nbody.c:185:14: note: 	stmt 1 _7 = *_2.vy;
nbody.c:185:14: note: node 0x3bc7fe8 (max_nunits=2, refcnt=1) vector(2) float
nbody.c:185:14: note: op template: _5 = fx.4_4 * dt_39(D);
nbody.c:185:14: note: 	stmt 0 _5 = fx.4_4 * dt_39(D);
nbody.c:185:14: note: 	stmt 1 _9 = fy.5_8 * dt_39(D);
nbody.c:185:14: note: 	children 0x3bc80e8 0x3bc8168
nbody.c:185:14: note: node (external) 0x3bc80e8 (max_nunits=1, refcnt=1) vector(2) float
nbody.c:185:14: note: 	{ fx.4_4, fy.5_8 }
nbody.c:185:14: note: node (external) 0x3bc8168 (max_nunits=1, refcnt=1) vector(2) float
nbody.c:185:14: note: 	{ dt_39(D), dt_39(D) }
nbody.c:185:14: note: ------>vectorizing SLP node starting from: _3 = *_2.vx;
nbody.c:185:14: note: transform load. ncopies = 1
nbody.c:185:14: note: create vector_type-pointer variable to type: vector(2) float  vectorizing a pointer ref: *_2.vx
nbody.c:185:14: note: created vectp.125_83
nbody.c:185:14: note: add new stmt: vect__3.126_82 = MEM <vector(2) float> [(float *)vectp.125_83];
nbody.c:185:14: note: add new stmt: vectp.125_81 = vectp.125_83 + 4;
nbody.c:185:14: note: ------>vectorizing SLP node starting from: _5 = fx.4_4 * dt_39(D);
nbody.c:185:14: note: transform binary/unary operation.
nbody.c:185:14: note: add new stmt: vect__5.127_78 = _80 * _79;
nbody.c:185:14: note: ------>vectorizing SLP node starting from: _6 = _3 + _5;
nbody.c:185:14: note: vect_is_simple_use: operand *_2.vx, type of def: internal
nbody.c:185:14: note: vect_is_simple_use: operand fx.4_4 * dt_39(D), type of def: internal
nbody.c:185:14: note: transform binary/unary operation.
nbody.c:185:14: note: add new stmt: vect__6.128_77 = vect__3.126_82 + vect__5.127_78;
nbody.c:185:14: note: ------>vectorizing SLP node starting from: *_2.vx = _6;
nbody.c:185:14: note: vect_is_simple_use: operand _3 + _5, type of def: internal
nbody.c:185:14: note: vect_is_simple_use: operand _7 + _9, type of def: internal
nbody.c:185:14: note: transform store. ncopies = 1
nbody.c:185:14: note: create vector_type-pointer variable to type: vector(2) float  vectorizing a pointer ref: *_2.vx
nbody.c:185:14: note: created vectp.130_76
nbody.c:185:14: note: add new stmt: MEM <vector(2) float> [(float *)vectp.130_76] = vect__6.128_77;
nbody.c:185:14: note: vectorizing stmts using SLP.
nbody.c:185:14: optimized: basic block part vectorized using 32 byte vectors
nbody.c:185:14: note: Vectorizing SLP tree:
nbody.c:185:14: note: node 0x3bc8268 (max_nunits=2, refcnt=1) vector(2) float
nbody.c:185:14: note: op template: *_16.x = _20;
nbody.c:185:14: note: 	stmt 0 *_16.x = _20;
nbody.c:185:14: note: 	stmt 1 *_16.y = _24;
nbody.c:185:14: note: 	children 0x3bc82e8
nbody.c:185:14: note: node 0x3bc82e8 (max_nunits=2, refcnt=1) vector(2) float
nbody.c:185:14: note: op template: _20 = _17 + _19;
nbody.c:185:14: note: 	stmt 0 _20 = _17 + _19;
nbody.c:185:14: note: 	stmt 1 _24 = _21 + _23;
nbody.c:185:14: note: 	children 0x3bc8368 0x3bc83e8
nbody.c:185:14: note: node 0x3bc8368 (max_nunits=2, refcnt=1) vector(2) float
nbody.c:185:14: note: op template: _17 = *_16.x;
nbody.c:185:14: note: 	stmt 0 _17 = *_16.x;
nbody.c:185:14: note: 	stmt 1 _21 = *_16.y;
nbody.c:185:14: note: node 0x3bc83e8 (max_nunits=2, refcnt=1) vector(2) float
nbody.c:185:14: note: op template: _19 = _18 * dt_39(D);
nbody.c:185:14: note: 	stmt 0 _19 = _18 * dt_39(D);
nbody.c:185:14: note: 	stmt 1 _23 = _22 * dt_39(D);
nbody.c:185:14: note: 	children 0x3bc8468 0x3bc84e8
nbody.c:185:14: note: node 0x3bc8468 (max_nunits=2, refcnt=1) vector(2) float
nbody.c:185:14: note: op template: _18 = *_16.vx;
nbody.c:185:14: note: 	stmt 0 _18 = *_16.vx;
nbody.c:185:14: note: 	stmt 1 _22 = *_16.vy;
nbody.c:185:14: note: node (external) 0x3bc84e8 (max_nunits=1, refcnt=1) vector(2) float
nbody.c:185:14: note: 	{ dt_39(D), dt_39(D) }
nbody.c:185:14: note: ------>vectorizing SLP node starting from: _17 = *_16.x;
nbody.c:185:14: note: transform load. ncopies = 1
nbody.c:185:14: note: create vector_type-pointer variable to type: vector(2) float  vectorizing a pointer ref: *_16.x
nbody.c:185:14: note: created vectp.132_74
nbody.c:185:14: note: add new stmt: vect__17.133_73 = MEM <vector(2) float> [(float *)vectp.132_74];
nbody.c:185:14: note: add new stmt: vectp.132_72 = vectp.132_74 + 16;
nbody.c:185:14: note: ------>vectorizing SLP node starting from: _18 = *_16.vx;
nbody.c:185:14: note: transform load. ncopies = 1
nbody.c:185:14: note: create vector_type-pointer variable to type: vector(2) float  vectorizing a pointer ref: *_16.vx
nbody.c:185:14: note: created vectp.135_71
nbody.c:185:14: note: add new stmt: vect__18.136_70 = MEM <vector(2) float> [(float *)vectp.135_71];
nbody.c:185:14: note: add new stmt: vectp.135_69 = vectp.135_71 + 16;
nbody.c:185:14: note: ------>vectorizing SLP node starting from: _19 = _18 * dt_39(D);
nbody.c:185:14: note: vect_is_simple_use: operand *_16.vx, type of def: internal
nbody.c:185:14: note: transform binary/unary operation.
nbody.c:185:14: note: add new stmt: vect__19.137_67 = vect__18.136_70 * _68;
nbody.c:185:14: note: ------>vectorizing SLP node starting from: _20 = _17 + _19;
nbody.c:185:14: note: vect_is_simple_use: operand *_16.x, type of def: internal
nbody.c:185:14: note: vect_is_simple_use: operand _18 * dt_39(D), type of def: internal
nbody.c:185:14: note: transform binary/unary operation.
nbody.c:185:14: note: add new stmt: vect__20.138_64 = vect__17.133_73 + vect__19.137_67;
nbody.c:185:14: note: extracting lane for live stmt _20 = _17 + _19;
nbody.c:185:14: note: extracting lane for live stmt _24 = _21 + _23;
nbody.c:185:14: note: ------>vectorizing SLP node starting from: *_16.x = _20;
nbody.c:185:14: note: vect_is_simple_use: operand _17 + _19, type of def: internal
nbody.c:185:14: note: vect_is_simple_use: operand _21 + _23, type of def: internal
nbody.c:185:14: note: transform store. ncopies = 1
nbody.c:185:14: note: create vector_type-pointer variable to type: vector(2) float  vectorizing a pointer ref: *_16.x
nbody.c:185:14: note: created vectp.140_58
nbody.c:185:14: note: add new stmt: MEM <vector(2) float> [(float *)vectp.140_58] = vect__20.138_64;
nbody.c:185:14: note: vectorizing stmts using SLP.
nbody.c:185:14: optimized: basic block part vectorized using 32 byte vectors
nbody.c:185:14: note: ***** The result for vector mode V32QI would be the same
BB 4 is always executed in loop 2
BB 3 is always executed in loop 1
loop 2's coldest_outermost_loop is 2, hotter_than_inner_loop is NULL
loop 1's coldest_outermost_loop is 1, hotter_than_inner_loop is NULL
nbody.c:183:21: note: considering unrolling loop 2 at BB 6
considering unrolling loop with constant number of iterations
considering unrolling loop with runtime-computable number of iterations
nbody.c:170:23: note: considering unrolling loop 1 at BB 4
considering unrolling loop with constant number of iterations
considering unrolling loop with runtime-computable number of iterations
nbody.c:268:11: missed: statement clobbers memory: drate_83 = sqrt (_32);
BB 5 is always executed in loop 1
loop 1's coldest_outermost_loop is 1, hotter_than_inner_loop is NULL
nbody.c:231:25: missed: statement clobbers memory: start_65 = omp_get_wtime ();
nbody.c:228:21: missed: couldn't vectorize loop
nbody.c:228:21: missed: not vectorized: control flow in loop.
nbody.c:193:5: note: vectorized 0 loops in function.
nbody.c:231:25: missed: statement clobbers memory: start_65 = omp_get_wtime ();
/usr/include/stdlib.h:495:10: missed: statement clobbers memory: _76 = strtoll (_1, 0B, 10);
nbody.c:212:28: missed: statement clobbers memory: p_46 = aligned_alloc (32, _2);
nbody.c:214:3: missed: statement clobbers memory: init (p_46, iftmp.7_38);
nbody.c:216:3: missed: statement clobbers memory: __builtin_puts (&"not done"[0]);
nbody.c:217:16: missed: statement clobbers memory: root_50 = createTree (p_46, iftmp.7_38);
nbody.c:218:3: missed: statement clobbers memory: __builtin_puts (&"done "[0]);
nbody.c:222:3: missed: statement clobbers memory: printf ("\n\x1b[1mTotal memory size:\x1b[0m %llu B, %llu KiB, %llu MiB\n\n", _2, _4, _3);
nbody.c:225:3: missed: statement clobbers memory: printf ("\x1b[1m%5s %10s %10s %8s\x1b[0m\n", "Step", "Time, s", "Interact/s", "GFLOP/s");
nbody.c:225:92: missed: statement clobbers memory: fflush (stdout.8_5);
nbody.c:231:25: missed: statement clobbers memory: start_65 = omp_get_wtime ();
nbody.c:233:7: missed: statement clobbers memory: move_particles (p_46, root_50, 9.99999977648258209228515625e-3, iftmp.7_38);
nbody.c:235:23: missed: statement clobbers memory: end_68 = omp_get_wtime ();
nbody.c:254:7: missed: statement clobbers memory: printf ("%5llu %10.3e %10.3e %8.1f %s\n", i_89, _25, _28, _26, iftmp.9_39);
nbody.c:261:7: missed: statement clobbers memory: fflush (stdout.10_29);
nbody.c:268:11: missed: statement clobbers memory: drate_83 = sqrt (_32);
nbody.c:270:3: missed: statement clobbers memory: __builtin_puts (&"-----------------------------------------------------"[0]);
nbody.c:271:3: missed: statement clobbers memory: printf ("\x1b[1m%s %4s \x1b[42m%10.1lf +- %.1lf GFLOP/s\x1b[0m\n", "Average performance:", "", rate_56, drate_84);
nbody.c:273:3: missed: statement clobbers memory: __builtin_puts (&"-----------------------------------------------------"[0]);
nbody.c:276:3: missed: statement clobbers memory: free (p_46);
nbody.c:277:3: missed: statement clobbers memory: free (root_50);
nbody.c:277:3: note: ***** Analysis failed with vector mode V4DI
nbody.c:277:3: note: ***** Skipping vector mode V32QI, which would repeat the analysis for V4DI
BB 5 is always executed in loop 1
loop 1's coldest_outermost_loop is 1, hotter_than_inner_loop is NULL
nbody.c:228:21: note: considering unrolling loop 1 at BB 5
considering unrolling loop with constant number of iterations
considering unrolling loop with runtime-computable number of iterations
nbody.c:62:11: note: Considering inline candidate addParticle/23.
nbody.c:62:11: missed:   Not inlining: recursive call.
nbody.c:60:31: note: Considering inline candidate createNode/22.
nbody.c:60:31: missed:   will not early inline: addParticle/23->createNode/22, call is cold and code would grow at least by 11
nbody.c:77:15: note: Considering inline candidate computeMass/24.
nbody.c:77:15: missed:   Not inlining: recursive call.
nbody.c:106:17: note: Considering inline candidate computeForce/25.
nbody.c:106:17: missed:   Not inlining: recursive call.
nbody.c:137:5: note: Considering inline candidate computeMass/24.
nbody.c:137:5: missed:   will not early inline: createTree/26->computeMass/24, growth 8 exceeds --param early-inlining-insns
nbody.c:134:9: note: Considering inline candidate addParticle/23.
nbody.c:134:9: optimized:  Inlining addParticle/23 into createTree/26.
nbody.c:130:18: note: Considering inline candidate createNode/22.
nbody.c:130:18: missed:   will not early inline: createTree/26->createNode/22, call is cold and code would grow at least by 11
nbody.c:174:7: note: Considering inline candidate computeForce/25.
nbody.c:174:7: missed:   will not early inline: move_particles/28->computeForce/25, call is cold and code would grow at least by 25
nbody.c:195:30: optimized:   Inlining atoll/13 into main/29 (always_inline).
nbody.c:232:7: note: Considering inline candidate move_particles/28.
nbody.c:232:7: missed:   will not early inline: main/29->move_particles/28, call is cold and code would grow at least by 50
nbody.c:216:16: note: Considering inline candidate createTree/26.
nbody.c:216:16: missed:   will not early inline: main/29->createTree/26, call is cold and code would grow at least by 64
nbody.c:213:3: note: Considering inline candidate init/27.
nbody.c:213:3: missed:   will not early inline: main/29->init/27, call is cold and code would grow at least by 41
nbody.c:276:3: missed:   not inlinable: main/29 -> free/40, function body not available
nbody.c:275:3: missed:   not inlinable: main/29 -> free/40, function body not available
nbody.c:272:3: missed:   not inlinable: main/29 -> __builtin_puts/32, function body not available
nbody.c:270:3: missed:   not inlinable: main/29 -> printf/34, function body not available
nbody.c:269:3: missed:   not inlinable: main/29 -> __builtin_puts/32, function body not available
nbody.c:267:11: missed:   not inlinable: main/29 -> sqrt/31, function body not available
nbody.c:260:7: missed:   not inlinable: main/29 -> fflush/38, function body not available
nbody.c:253:7: missed:   not inlinable: main/29 -> printf/34, function body not available
nbody.c:234:23: missed:   not inlinable: main/29 -> omp_get_wtime/39, function body not available
nbody.c:232:7: missed:   not inlinable: main/29 -> move_particles/28, --param max-inline-insns-auto limit reached
nbody.c:230:25: missed:   not inlinable: main/29 -> omp_get_wtime/39, function body not available
nbody.c:224:92: missed:   not inlinable: main/29 -> fflush/38, function body not available
nbody.c:224:3: missed:   not inlinable: main/29 -> printf/34, function body not available
nbody.c:221:3: missed:   not inlinable: main/29 -> printf/34, function body not available
nbody.c:217:3: missed:   not inlinable: main/29 -> __builtin_puts/32, function body not available
nbody.c:216:16: missed:   not inlinable: main/29 -> createTree/26, --param max-inline-insns-auto limit reached
nbody.c:215:3: missed:   not inlinable: main/29 -> __builtin_puts/32, function body not available
nbody.c:213:3: missed:   not inlinable: main/29 -> init/27, --param max-inline-insns-auto limit reached
nbody.c:211:28: missed:   not inlinable: main/29 -> aligned_alloc/36, function body not available
/usr/include/stdlib.h:495:10: missed:   not inlinable: main/29 -> strtoll/41, function body not available
nbody.c:187:7: missed:   not inlinable: move_particles/28 -> printf/34, function body not available
nbody.c:174:7: missed:   not inlinable: move_particles/28 -> computeForce/25, --param max-inline-insns-auto limit reached
nbody.c:159:22: missed:   not inlinable: init/27 -> rand/35, function body not available
nbody.c:158:29: missed:   not inlinable: init/27 -> rand/35, function body not available
nbody.c:157:22: missed:   not inlinable: init/27 -> rand/35, function body not available
nbody.c:155:28: missed:   not inlinable: init/27 -> rand/35, function body not available
nbody.c:154:21: missed:   not inlinable: init/27 -> rand/35, function body not available
nbody.c:153:28: missed:   not inlinable: init/27 -> rand/35, function body not available
nbody.c:150:21: missed:   not inlinable: init/27 -> rand/35, function body not available
nbody.c:149:21: missed:   not inlinable: init/27 -> rand/35, function body not available
nbody.c:136:5: missed:   not inlinable: createTree/26 -> __builtin_puts/32, function body not available
missed:   not inlinable: createTree/26 -> addParticle.part.0/42, --param max-inline-insns-auto limit reached
nbody.c:133:3: missed:   not inlinable: createTree/26 -> printf/34, function body not available
nbody.c:131:5: missed:   not inlinable: createTree/26 -> __builtin_puts/32, function body not available
nbody.c:129:5: missed:   not inlinable: createTree/26 -> __builtin_puts/32, function body not available
nbody.c:125:16: missed:   not inlinable: createTree/26 -> fmax/33, function body not available
nbody.c:125:16: missed:   not inlinable: createTree/26 -> fmax/33, function body not available
nbody.c:124:5: missed:   not inlinable: createTree/26 -> __builtin_puts/32, function body not available
nbody.c:106:17: missed:   not inlinable: computeForce/25 -> computeForce/25, --param max-inline-insns-auto limit reached
nbody.c:96:24: missed:   not inlinable: computeForce/25 -> sqrt/31, function body not available
missed:   not inlinable: addParticle/23 -> addParticle.part.0/42, --param max-inline-insns-auto limit reached
nbody.c:33:16: missed:   not inlinable: createNode/22 -> malloc/30, function body not available
nbody.c:62:11: optimized:  Inlined addParticle/45 into addParticle.part.0/42 which now has time 360.144856 and size 49, net change of +3.
nbody.c:77:15: missed:   not inlinable: computeMass.part.0/43 -> computeMass/24, --param max-inline-insns-auto limit reached
nbody.c:137:5: missed:   not inlinable: createTree/26 -> computeMass/24, --param max-inline-insns-auto limit reached
optimized:  Inlined computeMass.part.0/43 into computeMass/24 which now has time 72.729348 and size 46, net change of -13.
nbody.c:60:31: optimized:  Inlined createNode/46 into addParticle.part.0/42 which now has time 427.089860 and size 60, net change of +11.
nbody.c:130:18: optimized:  Inlined createNode/47 into createTree/26 which now has time 556.031780 and size 85, net change of +11.
Unit growth for small function inlining: 478->490 (2%)

Inlined 6 calls, eliminated 1 functions

BB 9 is always executed in loop 1
BB 7 is always executed in loop 1
BB 5 is always executed in loop 1
BB 3 is always executed in loop 1
BB 11 is always executed in loop 2
loop 1's coldest_outermost_loop is 1, hotter_than_inner_loop is NULL
loop 2's coldest_outermost_loop is 1, hotter_than_inner_loop is NULL
nbody.c:39:21: optimized: Loop 2 distributed: split to 0 loops and 1 library calls.
nbody.c:52:15: missed: failed: evolution of base is not affine.
nbody.c:51:11: missed: failed: evolution of base is not affine.
nbody.c:50:6: missed: statement clobbers memory: addParticle.part.0 (_23, p_26(D));
nbody.c:54:25: missed: couldn't vectorize loop
nbody.c:54:25: missed: not vectorized: control flow in loop.
nbody.c:50:6: note: vectorized 0 loops in function.
nbody.c:52:15: missed: failed: evolution of base is not affine.
nbody.c:51:11: missed: failed: evolution of base is not affine.
nbody.c:50:6: missed: statement clobbers memory: addParticle.part.0 (_23, p_26(D));
nbody.c:50:6: missed: statement clobbers memory: addParticle.part.0 (_23, p_26(D));
nbody.c:33:16: missed: statement clobbers memory: node_34 = malloc (104);
nbody.c:40:21: missed: statement clobbers memory: __builtin_memset (_61, 0, 64);
nbody.c:42:11: note: ***** Analysis succeeded with vector mode V8SF
nbody.c:42:11: note: SLPing BB part
nbody.c:34:12: note: Costing subgraph: 
nbody.c:34:12: note: node 0x3bf0938 (max_nunits=4, refcnt=1) vector(4) float
nbody.c:34:12: note: op template: node_34->cx = f_x_10;
nbody.c:34:12: note: 	stmt 0 node_34->cx = f_x_10;
nbody.c:34:12: note: 	stmt 1 node_34->cy = f_y_16;
nbody.c:34:12: note: 	stmt 2 node_34->cz = f_z_22;
nbody.c:34:12: note: 	stmt 3 node_34->size = _52;
nbody.c:34:12: note: 	children 0x3bf0a38
nbody.c:34:12: note: node (external) 0x3bf0a38 (max_nunits=1, refcnt=1) vector(4) float
nbody.c:34:12: note: 	{ f_x_10, f_y_16, f_z_22, _52 }
nbody.c:34:12: note: Cost model analysis: 
nbody.c:34:12: note: Cost model analysis for part in loop 1:
  Vector cost: 24
  Scalar cost: 48
nbody.c:42:11: note: Costing subgraph: 
nbody.c:42:11: note: node 0x3bf0ab8 (max_nunits=4, refcnt=1) vector(4) float
nbody.c:42:11: note: op template: node_34->m = 0.0;
nbody.c:42:11: note: 	stmt 0 node_34->m = 0.0;
nbody.c:42:11: note: 	stmt 1 node_34->cmx = 0.0;
nbody.c:42:11: note: 	stmt 2 node_34->cmy = 0.0;
nbody.c:42:11: note: 	stmt 3 node_34->cmz = 0.0;
nbody.c:42:11: note: 	children 0x3bf0b38
nbody.c:42:11: note: node (constant) 0x3bf0b38 (max_nunits=1, refcnt=1) vector(4) float
nbody.c:42:11: note: 	{ 0.0, 0.0, 0.0, 0.0 }
nbody.c:42:11: note: Cost model analysis: 
nbody.c:42:11: note: Cost model analysis for part in loop 1:
  Vector cost: 24
  Scalar cost: 48
nbody.c:42:11: note: Basic block will be vectorized using SLP
nbody.c:42:11: note: Vectorizing SLP tree:
nbody.c:42:11: note: node 0x3bf0938 (max_nunits=4, refcnt=1) vector(4) float
nbody.c:42:11: note: op template: node_34->cx = f_x_10;
nbody.c:42:11: note: 	stmt 0 node_34->cx = f_x_10;
nbody.c:42:11: note: 	stmt 1 node_34->cy = f_y_16;
nbody.c:42:11: note: 	stmt 2 node_34->cz = f_z_22;
nbody.c:42:11: note: 	stmt 3 node_34->size = _52;
nbody.c:42:11: note: 	children 0x3bf0a38
nbody.c:42:11: note: node (external) 0x3bf0a38 (max_nunits=1, refcnt=1) vector(4) float
nbody.c:42:11: note: 	{ f_x_10, f_y_16, f_z_22, _52 }
nbody.c:42:11: note: ------>vectorizing SLP node starting from: node_34->cx = f_x_10;
nbody.c:42:11: note: vect_is_simple_use: operand _15 + pretmp_62, type of def: internal
nbody.c:42:11: note: vect_is_simple_use: operand _21 + pretmp_64, type of def: internal
nbody.c:42:11: note: vect_is_simple_use: operand pretmp_24 * 5.0e-1, type of def: internal
nbody.c:42:11: note: transform store. ncopies = 1
nbody.c:42:11: note: create vector_type-pointer variable to type: vector(4) float  vectorizing a pointer ref: node_34->cx
nbody.c:42:11: note: created vectp.25_39
nbody.c:42:11: note: add new stmt: MEM <vector(4) float> [(float *)vectp.25_39] = _56;
nbody.c:42:11: note: vectorizing stmts using SLP.
nbody.c:42:11: optimized: basic block part vectorized using 32 byte vectors
nbody.c:42:11: note: Vectorizing SLP tree:
nbody.c:42:11: note: node 0x3bf0ab8 (max_nunits=4, refcnt=1) vector(4) float
nbody.c:42:11: note: op template: node_34->m = 0.0;
nbody.c:42:11: note: 	stmt 0 node_34->m = 0.0;
nbody.c:42:11: note: 	stmt 1 node_34->cmx = 0.0;
nbody.c:42:11: note: 	stmt 2 node_34->cmy = 0.0;
nbody.c:42:11: note: 	stmt 3 node_34->cmz = 0.0;
nbody.c:42:11: note: 	children 0x3bf0b38
nbody.c:42:11: note: node (constant) 0x3bf0b38 (max_nunits=1, refcnt=1) vector(4) float
nbody.c:42:11: note: 	{ 0.0, 0.0, 0.0, 0.0 }
nbody.c:42:11: note: ------>vectorizing SLP node starting from: node_34->m = 0.0;
nbody.c:42:11: note: vect_is_simple_use: operand 0.0, type of def: constant
nbody.c:42:11: note: vect_is_simple_use: operand 0.0, type of def: constant
nbody.c:42:11: note: vect_is_simple_use: operand 0.0, type of def: constant
nbody.c:42:11: note: transform store. ncopies = 1
nbody.c:42:11: note: create vector_type-pointer variable to type: vector(4) float  vectorizing a pointer ref: node_34->m
nbody.c:42:11: note: created vectp.27_57
nbody.c:42:11: note: add new stmt: MEM <vector(4) float> [(float *)vectp.27_57] = { 0.0, 0.0, 0.0, 0.0 };
nbody.c:42:11: note: vectorizing stmts using SLP.
nbody.c:42:11: optimized: basic block part vectorized using 32 byte vectors
nbody.c:42:11: note: ***** The result for vector mode V32QI would be the same
BB 9 is always executed in loop 1
BB 7 is always executed in loop 1
BB 5 is always executed in loop 1
BB 3 is always executed in loop 1
loop 1's coldest_outermost_loop is 1, hotter_than_inner_loop is NULL
nbody.c:54:25: note: considering unrolling loop 1 at BB 3
considering unrolling loop with constant number of iterations
considering unrolling loop with runtime-computable number of iterations
BB 3 is always executed in loop 1
loop 1's coldest_outermost_loop is 1, hotter_than_inner_loop is NULL
nbody.c:39:21: optimized: Loop 1 distributed: split to 0 loops and 1 library calls.
nbody.c:32:7: note: vectorized 0 loops in function.
nbody.c:33:16: missed: statement clobbers memory: node_5 = malloc (104);
nbody.c:40:21: missed: statement clobbers memory: __builtin_memset (_22, 0, 64);
nbody.c:42:11: note: ***** Analysis succeeded with vector mode V8SF
nbody.c:42:11: note: SLPing BB part
nbody.c:34:12: note: Costing subgraph: 
nbody.c:34:12: note: node 0x3bf0938 (max_nunits=4, refcnt=1) vector(4) float
nbody.c:34:12: note: op template: node_5->cx = x_6(D);
nbody.c:34:12: note: 	stmt 0 node_5->cx = x_6(D);
nbody.c:34:12: note: 	stmt 1 node_5->cy = y_8(D);
nbody.c:34:12: note: 	stmt 2 node_5->cz = z_10(D);
nbody.c:34:12: note: 	stmt 3 node_5->size = size_12(D);
nbody.c:34:12: note: 	children 0x3bf09b8
nbody.c:34:12: note: node (external) 0x3bf09b8 (max_nunits=1, refcnt=1) vector(4) float
nbody.c:34:12: note: 	{ x_6(D), y_8(D), z_10(D), size_12(D) }
nbody.c:34:12: note: Cost model analysis: 
nbody.c:34:12: note: Cost model analysis for part in loop 0:
  Vector cost: 24
  Scalar cost: 48
nbody.c:42:11: note: Costing subgraph: 
nbody.c:42:11: note: node 0x3bf0a38 (max_nunits=4, refcnt=1) vector(4) float
nbody.c:42:11: note: op template: node_5->m = 0.0;
nbody.c:42:11: note: 	stmt 0 node_5->m = 0.0;
nbody.c:42:11: note: 	stmt 1 node_5->cmx = 0.0;
nbody.c:42:11: note: 	stmt 2 node_5->cmy = 0.0;
nbody.c:42:11: note: 	stmt 3 node_5->cmz = 0.0;
nbody.c:42:11: note: 	children 0x3bf0ab8
nbody.c:42:11: note: node (constant) 0x3bf0ab8 (max_nunits=1, refcnt=1) vector(4) float
nbody.c:42:11: note: 	{ 0.0, 0.0, 0.0, 0.0 }
nbody.c:42:11: note: Cost model analysis: 
nbody.c:42:11: note: Cost model analysis for part in loop 0:
  Vector cost: 24
  Scalar cost: 48
nbody.c:42:11: note: Basic block will be vectorized using SLP
nbody.c:42:11: note: Vectorizing SLP tree:
nbody.c:42:11: note: node 0x3bf0938 (max_nunits=4, refcnt=1) vector(4) float
nbody.c:42:11: note: op template: node_5->cx = x_6(D);
nbody.c:42:11: note: 	stmt 0 node_5->cx = x_6(D);
nbody.c:42:11: note: 	stmt 1 node_5->cy = y_8(D);
nbody.c:42:11: note: 	stmt 2 node_5->cz = z_10(D);
nbody.c:42:11: note: 	stmt 3 node_5->size = size_12(D);
nbody.c:42:11: note: 	children 0x3bf09b8
nbody.c:42:11: note: node (external) 0x3bf09b8 (max_nunits=1, refcnt=1) vector(4) float
nbody.c:42:11: note: 	{ x_6(D), y_8(D), z_10(D), size_12(D) }
nbody.c:42:11: note: ------>vectorizing SLP node starting from: node_5->cx = x_6(D);
nbody.c:42:11: note: vect_is_simple_use: operand y_8(D), type of def: external
nbody.c:42:11: note: vect_is_simple_use: operand z_10(D), type of def: external
nbody.c:42:11: note: vect_is_simple_use: operand size_12(D), type of def: external
nbody.c:42:11: note: transform store. ncopies = 1
nbody.c:42:11: note: create vector_type-pointer variable to type: vector(4) float  vectorizing a pointer ref: node_5->cx
nbody.c:42:11: note: created vectp.43_2
nbody.c:42:11: note: add new stmt: MEM <vector(4) float> [(float *)vectp.43_2] = _25;
nbody.c:42:11: note: vectorizing stmts using SLP.
nbody.c:42:11: optimized: basic block part vectorized using 32 byte vectors
nbody.c:42:11: note: Vectorizing SLP tree:
nbody.c:42:11: note: node 0x3bf0a38 (max_nunits=4, refcnt=1) vector(4) float
nbody.c:42:11: note: op template: node_5->m = 0.0;
nbody.c:42:11: note: 	stmt 0 node_5->m = 0.0;
nbody.c:42:11: note: 	stmt 1 node_5->cmx = 0.0;
nbody.c:42:11: note: 	stmt 2 node_5->cmy = 0.0;
nbody.c:42:11: note: 	stmt 3 node_5->cmz = 0.0;
nbody.c:42:11: note: 	children 0x3bf0ab8
nbody.c:42:11: note: node (constant) 0x3bf0ab8 (max_nunits=1, refcnt=1) vector(4) float
nbody.c:42:11: note: 	{ 0.0, 0.0, 0.0, 0.0 }
nbody.c:42:11: note: ------>vectorizing SLP node starting from: node_5->m = 0.0;
nbody.c:42:11: note: vect_is_simple_use: operand 0.0, type of def: constant
nbody.c:42:11: note: vect_is_simple_use: operand 0.0, type of def: constant
nbody.c:42:11: note: vect_is_simple_use: operand 0.0, type of def: constant
nbody.c:42:11: note: transform store. ncopies = 1
nbody.c:42:11: note: create vector_type-pointer variable to type: vector(4) float  vectorizing a pointer ref: node_5->m
nbody.c:42:11: note: created vectp.45_23
nbody.c:42:11: note: add new stmt: MEM <vector(4) float> [(float *)vectp.45_23] = { 0.0, 0.0, 0.0, 0.0 };
nbody.c:42:11: note: vectorizing stmts using SLP.
nbody.c:42:11: optimized: basic block part vectorized using 32 byte vectors
nbody.c:42:11: note: ***** The result for vector mode V32QI would be the same
nbody.c:50:6: note: vectorized 0 loops in function.
nbody.c:50:6: missed: statement clobbers memory: addParticle.part.0 (node_5(D), p_8(D));
nbody.c:65:1: note: ***** Analysis failed with vector mode V4DI
nbody.c:65:1: note: ***** Skipping vector mode V32QI, which would repeat the analysis for V4DI
BB 4 is always executed in loop 2
loop 2's coldest_outermost_loop is 2, hotter_than_inner_loop is NULL
nbody.c:73:17: optimized: sinking common stores to node_10(D)->cmz
nbody.c:77:15: missed: statement clobbers memory: computeMass (_16);
nbody.c:75:25: missed: couldn't vectorize loop
nbody.c:75:25: missed: not vectorized: control flow in loop.
nbody.c:68:6: note: vectorized 0 loops in function.
nbody.c:77:15: missed: statement clobbers memory: computeMass (_16);
nbody.c:77:15: missed: statement clobbers memory: computeMass (_16);
nbody.c:84:17: note: ***** Analysis succeeded with vector mode V4DI
nbody.c:84:17: note: SLPing BB part
nbody.c:84:17: note: Costing subgraph: 
nbody.c:84:17: note: node 0x3c82a58 (max_nunits=2, refcnt=1) vector(2) float
nbody.c:84:17: note: op template: node_10(D)->cmx = _37;
nbody.c:84:17: note: 	stmt 0 node_10(D)->cmx = _37;
nbody.c:84:17: note: 	stmt 1 node_10(D)->cmy = _39;
nbody.c:84:17: note: 	children 0x3c82ad8
nbody.c:84:17: note: node 0x3c82ad8 (max_nunits=2, refcnt=1) vector(2) float
nbody.c:84:17: note: op template: _37 = _35 / _36;
nbody.c:84:17: note: 	stmt 0 _37 = _35 / _36;
nbody.c:84:17: note: 	stmt 1 _39 = _38 / _36;
nbody.c:84:17: note: 	children 0x3c82b58 0x3c82bd8
nbody.c:84:17: note: node 0x3c82b58 (max_nunits=2, refcnt=1) vector(2) float
nbody.c:84:17: note: op template: _35 = node_10(D)->cmx;
nbody.c:84:17: note: 	stmt 0 _35 = node_10(D)->cmx;
nbody.c:84:17: note: 	stmt 1 _38 = node_10(D)->cmy;
nbody.c:84:17: note: node 0x3c82bd8 (max_nunits=2, refcnt=1) vector(2) float
nbody.c:84:17: note: op template: _36 = node_10(D)->m;
nbody.c:84:17: note: 	stmt 0 _36 = node_10(D)->m;
nbody.c:84:17: note: 	stmt 1 _36 = node_10(D)->m;
nbody.c:84:17: note: 	load permutation { 0 0 }
nbody.c:84:17: note: Cost model analysis: 
nbody.c:84:17: note: Cost model analysis for part in loop 0:
  Vector cost: 120
  Scalar cost: 204
nbody.c:84:17: note: Basic block will be vectorized using SLP
nbody.c:84:17: note: Vectorizing SLP tree:
nbody.c:84:17: note: node 0x3c82a58 (max_nunits=2, refcnt=1) vector(2) float
nbody.c:84:17: note: op template: node_10(D)->cmx = _37;
nbody.c:84:17: note: 	stmt 0 node_10(D)->cmx = _37;
nbody.c:84:17: note: 	stmt 1 node_10(D)->cmy = _39;
nbody.c:84:17: note: 	children 0x3c82ad8
nbody.c:84:17: note: node 0x3c82ad8 (max_nunits=2, refcnt=1) vector(2) float
nbody.c:84:17: note: op template: _37 = _35 / _36;
nbody.c:84:17: note: 	stmt 0 _37 = _35 / _36;
nbody.c:84:17: note: 	stmt 1 _39 = _38 / _36;
nbody.c:84:17: note: 	children 0x3c82b58 0x3c82bd8
nbody.c:84:17: note: node 0x3c82b58 (max_nunits=2, refcnt=1) vector(2) float
nbody.c:84:17: note: op template: _35 = node_10(D)->cmx;
nbody.c:84:17: note: 	stmt 0 _35 = node_10(D)->cmx;
nbody.c:84:17: note: 	stmt 1 _38 = node_10(D)->cmy;
nbody.c:84:17: note: node 0x3c82bd8 (max_nunits=2, refcnt=1) vector(2) float
nbody.c:84:17: note: op template: _36 = node_10(D)->m;
nbody.c:84:17: note: 	stmt 0 _36 = node_10(D)->m;
nbody.c:84:17: note: 	stmt 1 _36 = node_10(D)->m;
nbody.c:84:17: note: 	load permutation { 0 0 }
nbody.c:84:17: note: ------>vectorizing SLP node starting from: _35 = node_10(D)->cmx;
nbody.c:84:17: note: transform load. ncopies = 1
nbody.c:84:17: note: create vector_type-pointer variable to type: vector(2) float  vectorizing a pointer ref: node_10(D)->cmx
nbody.c:84:17: note: created vectp.54_15
nbody.c:84:17: note: add new stmt: vect__35.55_8 = MEM <vector(2) float> [(float *)vectp.54_15];
nbody.c:84:17: note: add new stmt: vectp.54_53 = vectp.54_15 + 8;
nbody.c:84:17: note: ------>vectorizing SLP node starting from: _36 = node_10(D)->m;
nbody.c:84:17: note: transform load. ncopies = 1
nbody.c:84:17: note: create vector_type-pointer variable to type: vector(2) float  vectorizing a pointer ref: node_10(D)->m
nbody.c:84:17: note: created vectp.57_54
nbody.c:84:17: note: add new stmt: vect__36.58_55 = MEM <vector(2) float> [(float *)vectp.57_54];
nbody.c:84:17: note: add new stmt: vectp.57_56 = vectp.57_54 + 8;
nbody.c:84:17: note: add new stmt: vect__36.59_57 = MEM <vector(2) float> [(float *)vectp.57_56];
nbody.c:84:17: note: add new stmt: vect__36.60_58 = VEC_PERM_EXPR <vect__36.58_55, vect__36.58_55, { 0, 0 }>;
nbody.c:84:17: note: extracting lane for live stmt _36 = node_10(D)->m;
nbody.c:84:17: note: extracting lane for live stmt _36 = node_10(D)->m;
nbody.c:84:17: note: ------>vectorizing SLP node starting from: _37 = _35 / _36;
nbody.c:84:17: note: vect_is_simple_use: operand node_10(D)->cmx, type of def: internal
nbody.c:84:17: note: vect_is_simple_use: operand node_10(D)->m, type of def: internal
nbody.c:84:17: note: transform binary/unary operation.
nbody.c:84:17: note: add new stmt: vect__37.61_61 = vect__35.55_8 / vect__36.60_58;
nbody.c:84:17: note: ------>vectorizing SLP node starting from: node_10(D)->cmx = _37;
nbody.c:84:17: note: vect_is_simple_use: operand _35 / _36, type of def: internal
nbody.c:84:17: note: vect_is_simple_use: operand _38 / _36, type of def: internal
nbody.c:84:17: note: transform store. ncopies = 1
nbody.c:84:17: note: create vector_type-pointer variable to type: vector(2) float  vectorizing a pointer ref: node_10(D)->cmx
nbody.c:84:17: note: created vectp.63_62
nbody.c:84:17: note: add new stmt: MEM <vector(2) float> [(float *)vectp.63_62] = vect__37.61_61;
nbody.c:84:17: note: vectorizing stmts using SLP.
nbody.c:84:17: optimized: basic block part vectorized using 32 byte vectors
nbody.c:84:17: note: ***** The result for vector mode V32QI would be the same
BB 4 is always executed in loop 2
loop 2's coldest_outermost_loop is 2, hotter_than_inner_loop is NULL
nbody.c:75:25: note: considering unrolling loop 2 at BB 5
considering unrolling loop with constant number of iterations
considering unrolling loop with runtime-computable number of iterations
nbody.c:96:24: missed: statement clobbers memory: _55 = sqrt (_13);
BB 7 is always executed in loop 1
loop 1's coldest_outermost_loop is 1, hotter_than_inner_loop is NULL
nbody.c:106:17: missed: statement clobbers memory: computeForce (_30, p_37(D), theta_43(D), fx_44(D), fy_45(D), fz_46(D));
nbody.c:104:27: missed: couldn't vectorize loop
nbody.c:104:27: missed: not vectorized: control flow in loop.
nbody.c:91:6: note: vectorized 0 loops in function.
nbody.c:106:17: missed: statement clobbers memory: computeForce (_30, p_37(D), theta_43(D), fx_44(D), fy_45(D), fz_46(D));
nbody.c:96:24: missed: statement clobbers memory: _55 = sqrt (_13);
nbody.c:106:17: missed: statement clobbers memory: computeForce (_30, p_37(D), theta_43(D), fx_44(D), fy_45(D), fz_46(D));
nbody.c:110:1: note: ***** Analysis failed with vector mode V8SF
nbody.c:110:1: note: ***** Skipping vector mode V32QI, which would repeat the analysis for V8SF
BB 7 is always executed in loop 1
loop 1's coldest_outermost_loop is 1, hotter_than_inner_loop is NULL
nbody.c:104:27: note: considering unrolling loop 1 at BB 8
considering unrolling loop with constant number of iterations
considering unrolling loop with runtime-computable number of iterations
BB 19 is always executed in loop 2
BB 17 is always executed in loop 3
BB 15 is always executed in loop 1
BB 13 is always executed in loop 1
BB 11 is always executed in loop 1
BB 9 is always executed in loop 1
BB 7 is always executed in loop 1
BB 5 is always executed in loop 1
BB 3 is always executed in loop 1
loop 2's coldest_outermost_loop is 2, hotter_than_inner_loop is NULL
loop 3's coldest_outermost_loop is 3, hotter_than_inner_loop is NULL
loop 1's coldest_outermost_loop is 1, hotter_than_inner_loop is NULL
nbody.c:39:21: optimized: Loop 3 distributed: split to 0 loops and 1 library calls.
nbody.c:133:3: missed: statement clobbers memory: printf ("ADDING ,,,,,,,,,, %d \n", i_98);
nbody.c:132:23: missed: couldn't vectorize loop
nbody.c:132:23: missed: not vectorized: control flow in loop.
nbody.c:116:23: missed: couldn't vectorize loop
nbody.c:112:7: missed: not vectorized: unsupported use in stmt.
nbody.c:116:23: note: ***** Analysis failed with vector mode V8SF
nbody.c:116:23: note: ***** Skipping vector mode V32QI, which would repeat the analysis for V8SF
nbody.c:112:7: note: vectorized 0 loops in function.
nbody.c:133:3: missed: statement clobbers memory: printf ("ADDING ,,,,,,,,,, %d \n", i_98);
nbody.c:124:5: missed: statement clobbers memory: __builtin_puts (&"loop 1"[0]);
nbody.c:129:5: missed: statement clobbers memory: __builtin_puts (&"bf create node "[0]);
nbody.c:33:16: missed: statement clobbers memory: node_65 = malloc (104);
nbody.c:40:21: missed: statement clobbers memory: __builtin_memset (_30, 0, 64);
nbody.c:131:5: missed: statement clobbers memory: __builtin_puts (&"afteer create node "[0]);
nbody.c:133:3: missed: statement clobbers memory: printf ("ADDING ,,,,,,,,,, %d \n", i_98);
nbody.c:112:7: missed: statement clobbers memory: addParticle.part.0 (node_65, _21);
nbody.c:136:5: missed: statement clobbers memory: __builtin_puts (&"loop2"[0]);
nbody.c:137:5: missed: statement clobbers memory: computeMass (node_65);
nbody.c:42:11: note: ***** Analysis succeeded with vector mode V8SF
nbody.c:42:11: note: SLPing BB part
nbody.c:34:12: note: Costing subgraph: 
nbody.c:34:12: note: node 0x3d64c28 (max_nunits=4, refcnt=1) vector(4) float
nbody.c:34:12: note: op template: *node_65.cx = x_49;
nbody.c:34:12: note: 	stmt 0 *node_65.cx = x_49;
nbody.c:34:12: note: 	stmt 1 *node_65.cy = y_50;
nbody.c:34:12: note: 	stmt 2 *node_65.cz = z_51;
nbody.c:34:12: note: 	stmt 3 *node_65.size = size_48;
nbody.c:34:12: note: 	children 0x3d64d28
nbody.c:34:12: note: node (external) 0x3d64d28 (max_nunits=1, refcnt=1) vector(4) float
nbody.c:34:12: note: 	{ x_49, y_50, z_51, size_48 }
nbody.c:34:12: note: Cost model analysis: 
nbody.c:34:12: note: Cost model analysis for part in loop 0:
  Vector cost: 24
  Scalar cost: 48
nbody.c:42:11: note: Costing subgraph: 
nbody.c:42:11: note: node 0x3d64da8 (max_nunits=4, refcnt=1) vector(4) float
nbody.c:42:11: note: op template: *node_65.m = 0.0;
nbody.c:42:11: note: 	stmt 0 *node_65.m = 0.0;
nbody.c:42:11: note: 	stmt 1 *node_65.cmx = 0.0;
nbody.c:42:11: note: 	stmt 2 *node_65.cmy = 0.0;
nbody.c:42:11: note: 	stmt 3 *node_65.cmz = 0.0;
nbody.c:42:11: note: 	children 0x3d64e28
nbody.c:42:11: note: node (constant) 0x3d64e28 (max_nunits=1, refcnt=1) vector(4) float
nbody.c:42:11: note: 	{ 0.0, 0.0, 0.0, 0.0 }
nbody.c:42:11: note: Cost model analysis: 
nbody.c:42:11: note: Cost model analysis for part in loop 0:
  Vector cost: 24
  Scalar cost: 48
nbody.c:42:11: note: Basic block will be vectorized using SLP
nbody.c:42:11: note: Vectorizing SLP tree:
nbody.c:42:11: note: node 0x3d64c28 (max_nunits=4, refcnt=1) vector(4) float
nbody.c:42:11: note: op template: *node_65.cx = x_49;
nbody.c:42:11: note: 	stmt 0 *node_65.cx = x_49;
nbody.c:42:11: note: 	stmt 1 *node_65.cy = y_50;
nbody.c:42:11: note: 	stmt 2 *node_65.cz = z_51;
nbody.c:42:11: note: 	stmt 3 *node_65.size = size_48;
nbody.c:42:11: note: 	children 0x3d64d28
nbody.c:42:11: note: node (external) 0x3d64d28 (max_nunits=1, refcnt=1) vector(4) float
nbody.c:42:11: note: 	{ x_49, y_50, z_51, size_48 }
nbody.c:42:11: note: ------>vectorizing SLP node starting from: *node_65.cx = x_49;
nbody.c:42:11: note: vect_is_simple_use: operand _17 * 5.0e-1, type of def: internal
nbody.c:42:11: note: vect_is_simple_use: operand _18 * 5.0e-1, type of def: internal
nbody.c:42:11: note: vect_is_simple_use: operand (f32) _15, type of def: internal
nbody.c:42:11: note: transform store. ncopies = 1
nbody.c:42:11: note: create vector_type-pointer variable to type: vector(4) float  vectorizing a pointer ref: *node_65.cx
nbody.c:42:11: note: created vectp.96_97
nbody.c:42:11: note: add new stmt: MEM <vector(4) float> [(float *)vectp.96_97] = _32;
nbody.c:42:11: note: vectorizing stmts using SLP.
nbody.c:42:11: optimized: basic block part vectorized using 32 byte vectors
nbody.c:42:11: note: Vectorizing SLP tree:
nbody.c:42:11: note: node 0x3d64da8 (max_nunits=4, refcnt=1) vector(4) float
nbody.c:42:11: note: op template: *node_65.m = 0.0;
nbody.c:42:11: note: 	stmt 0 *node_65.m = 0.0;
nbody.c:42:11: note: 	stmt 1 *node_65.cmx = 0.0;
nbody.c:42:11: note: 	stmt 2 *node_65.cmy = 0.0;
nbody.c:42:11: note: 	stmt 3 *node_65.cmz = 0.0;
nbody.c:42:11: note: 	children 0x3d64e28
nbody.c:42:11: note: node (constant) 0x3d64e28 (max_nunits=1, refcnt=1) vector(4) float
nbody.c:42:11: note: 	{ 0.0, 0.0, 0.0, 0.0 }
nbody.c:42:11: note: ------>vectorizing SLP node starting from: *node_65.m = 0.0;
nbody.c:42:11: note: vect_is_simple_use: operand 0.0, type of def: constant
nbody.c:42:11: note: vect_is_simple_use: operand 0.0, type of def: constant
nbody.c:42:11: note: vect_is_simple_use: operand 0.0, type of def: constant
nbody.c:42:11: note: transform store. ncopies = 1
nbody.c:42:11: note: create vector_type-pointer variable to type: vector(4) float  vectorizing a pointer ref: *node_65.m
nbody.c:42:11: note: created vectp.98_93
nbody.c:42:11: note: add new stmt: MEM <vector(4) float> [(float *)vectp.98_93] = { 0.0, 0.0, 0.0, 0.0 };
nbody.c:42:11: note: vectorizing stmts using SLP.
nbody.c:42:11: optimized: basic block part vectorized using 32 byte vectors
nbody.c:42:11: note: ***** The result for vector mode V32QI would be the same
BB 19 is always executed in loop 2
BB 43 is always executed in loop 4
BB 41 is always executed in loop 4
BB 39 is always executed in loop 4
BB 37 is always executed in loop 4
BB 35 is always executed in loop 4
BB 33 is always executed in loop 4
BB 31 is always executed in loop 4
loop 2's coldest_outermost_loop is 2, hotter_than_inner_loop is NULL
loop 4's coldest_outermost_loop is 4, hotter_than_inner_loop is NULL
nbody.c:132:23: note: considering unrolling loop 2 at BB 9
considering unrolling loop with constant number of iterations
considering unrolling loop with runtime-computable number of iterations
nbody.c:116:23: note: considering unrolling loop 4 at BB 4
considering unrolling loop with constant number of iterations
considering unrolling loop with runtime-computable number of iterations
BB 3 is always executed in loop 1
loop 1's coldest_outermost_loop is 1, hotter_than_inner_loop is NULL
nbody.c:149:21: missed: statement clobbers memory: _1 = rand ();
nbody.c:146:21: missed: couldn't vectorize loop
nbody.c:146:21: missed: not vectorized: control flow in loop.
nbody.c:144:6: note: vectorized 0 loops in function.
nbody.c:149:21: missed: statement clobbers memory: _1 = rand ();
nbody.c:149:21: missed: statement clobbers memory: _1 = rand ();
nbody.c:150:21: missed: statement clobbers memory: _2 = rand ();
nbody.c:153:28: missed: statement clobbers memory: _3 = rand ();
nbody.c:154:21: missed: statement clobbers memory: _9 = rand ();
nbody.c:155:28: missed: statement clobbers memory: _12 = rand ();
nbody.c:157:22: missed: statement clobbers memory: _16 = rand ();
nbody.c:158:29: missed: statement clobbers memory: _19 = rand ();
nbody.c:159:22: missed: statement clobbers memory: _23 = rand ();
nbody.c:162:1: note: ***** Analysis failed with vector mode V8SF
nbody.c:162:1: note: ***** Skipping vector mode V32QI, which would repeat the analysis for V8SF
BB 3 is always executed in loop 1
loop 1's coldest_outermost_loop is 1, hotter_than_inner_loop is NULL
nbody.c:146:21: note: considering unrolling loop 1 at BB 4
considering unrolling loop with constant number of iterations
considering unrolling loop with runtime-computable number of iterations
BB 4 is always executed in loop 2
BB 3 is always executed in loop 1
loop 2's coldest_outermost_loop is 2, hotter_than_inner_loop is NULL
loop 1's coldest_outermost_loop is 1, hotter_than_inner_loop is NULL
nbody.c:187:7: missed: statement clobbers memory: printf ("%f %f %f\n", _31, _30, _29);
nbody.c:174:7: missed: statement clobbers memory: computeForce (root_48(D), _2, 5.0e-1, &fx, &fy, &fz);
nbody.c:182:21: missed: couldn't vectorize loop
nbody.c:187:7: missed: statement clobbers memory: printf ("%f %f %f\n", _31, _30, _29);
nbody.c:169:23: missed: couldn't vectorize loop
nbody.c:174:7: missed: statement clobbers memory: computeForce (root_48(D), _2, 5.0e-1, &fx, &fy, &fz);
nbody.c:165:6: note: vectorized 0 loops in function.
nbody.c:174:7: missed: statement clobbers memory: computeForce (root_48(D), _2, 5.0e-1, &fx, &fy, &fz);
nbody.c:187:7: missed: statement clobbers memory: printf ("%f %f %f\n", _31, _30, _29);
nbody.c:174:7: missed: statement clobbers memory: computeForce (root_48(D), _2, 5.0e-1, &fx, &fy, &fz);
nbody.c:187:7: missed: statement clobbers memory: printf ("%f %f %f\n", _31, _30, _29);
nbody.c:184:14: note: ***** Analysis succeeded with vector mode V8SF
nbody.c:184:14: note: SLPing BB part
nbody.c:176:15: note: Costing subgraph: 
nbody.c:176:15: note: node 0x3c60858 (max_nunits=2, refcnt=1) vector(2) float
nbody.c:176:15: note: op template: *_2.vx = _6;
nbody.c:176:15: note: 	stmt 0 *_2.vx = _6;
nbody.c:176:15: note: 	stmt 1 *_2.vy = _10;
nbody.c:176:15: note: 	children 0x3c608d8
nbody.c:176:15: note: node 0x3c608d8 (max_nunits=2, refcnt=1) vector(2) float
nbody.c:176:15: note: op template: _6 = _3 + _5;
nbody.c:176:15: note: 	stmt 0 _6 = _3 + _5;
nbody.c:176:15: note: 	stmt 1 _10 = _7 + _9;
nbody.c:176:15: note: 	children 0x3c60958 0x3c609d8
nbody.c:176:15: note: node 0x3c60958 (max_nunits=2, refcnt=1) vector(2) float
nbody.c:176:15: note: op template: _3 = *_2.vx;
nbody.c:176:15: note: 	stmt 0 _3 = *_2.vx;
nbody.c:176:15: note: 	stmt 1 _7 = *_2.vy;
nbody.c:176:15: note: node 0x3c609d8 (max_nunits=2, refcnt=1) vector(2) float
nbody.c:176:15: note: op template: _5 = fx.4_4 * dt_39(D);
nbody.c:176:15: note: 	stmt 0 _5 = fx.4_4 * dt_39(D);
nbody.c:176:15: note: 	stmt 1 _9 = fy.5_8 * dt_39(D);
nbody.c:176:15: note: 	children 0x3c60ad8 0x3c60b58
nbody.c:176:15: note: node (external) 0x3c60ad8 (max_nunits=1, refcnt=1) vector(2) float
nbody.c:176:15: note: 	{ fx.4_4, fy.5_8 }
nbody.c:176:15: note: node (external) 0x3c60b58 (max_nunits=1, refcnt=1) vector(2) float
nbody.c:176:15: note: 	{ dt_39(D), dt_39(D) }
nbody.c:176:15: note: Cost model analysis: 
nbody.c:176:15: note: Cost model analysis for part in loop 1:
  Vector cost: 60
  Scalar cost: 104
nbody.c:184:14: note: Costing subgraph: 
nbody.c:184:14: note: node 0x3c60c58 (max_nunits=2, refcnt=1) vector(2) float
nbody.c:184:14: note: op template: *_16.x = _20;
nbody.c:184:14: note: 	stmt 0 *_16.x = _20;
nbody.c:184:14: note: 	stmt 1 *_16.y = _24;
nbody.c:184:14: note: 	children 0x3c60cd8
nbody.c:184:14: note: node 0x3c60cd8 (max_nunits=2, refcnt=1) vector(2) float
nbody.c:184:14: note: op template: _20 = _17 + _19;
nbody.c:184:14: note: 	stmt 0 _20 = _17 + _19;
nbody.c:184:14: note: 	stmt 1 _24 = _21 + _23;
nbody.c:184:14: note: 	children 0x3c60d58 0x3c60dd8
nbody.c:184:14: note: node 0x3c60d58 (max_nunits=2, refcnt=1) vector(2) float
nbody.c:184:14: note: op template: _17 = *_16.x;
nbody.c:184:14: note: 	stmt 0 _17 = *_16.x;
nbody.c:184:14: note: 	stmt 1 _21 = *_16.y;
nbody.c:184:14: note: node 0x3c60dd8 (max_nunits=2, refcnt=1) vector(2) float
nbody.c:184:14: note: op template: _19 = _18 * dt_39(D);
nbody.c:184:14: note: 	stmt 0 _19 = _18 * dt_39(D);
nbody.c:184:14: note: 	stmt 1 _23 = _22 * dt_39(D);
nbody.c:184:14: note: 	children 0x3c60e58 0x3c60ed8
nbody.c:184:14: note: node 0x3c60e58 (max_nunits=2, refcnt=1) vector(2) float
nbody.c:184:14: note: op template: _18 = *_16.vx;
nbody.c:184:14: note: 	stmt 0 _18 = *_16.vx;
nbody.c:184:14: note: 	stmt 1 _22 = *_16.vy;
nbody.c:184:14: note: node (external) 0x3c60ed8 (max_nunits=1, refcnt=1) vector(2) float
nbody.c:184:14: note: 	{ dt_39(D), dt_39(D) }
nbody.c:184:14: note: Cost model analysis: 
nbody.c:184:14: note: Cost model analysis for part in loop 2:
  Vector cost: 76
  Scalar cost: 128
nbody.c:184:14: note: Basic block will be vectorized using SLP
nbody.c:184:14: note: Vectorizing SLP tree:
nbody.c:184:14: note: node 0x3c60858 (max_nunits=2, refcnt=1) vector(2) float
nbody.c:184:14: note: op template: *_2.vx = _6;
nbody.c:184:14: note: 	stmt 0 *_2.vx = _6;
nbody.c:184:14: note: 	stmt 1 *_2.vy = _10;
nbody.c:184:14: note: 	children 0x3c608d8
nbody.c:184:14: note: node 0x3c608d8 (max_nunits=2, refcnt=1) vector(2) float
nbody.c:184:14: note: op template: _6 = _3 + _5;
nbody.c:184:14: note: 	stmt 0 _6 = _3 + _5;
nbody.c:184:14: note: 	stmt 1 _10 = _7 + _9;
nbody.c:184:14: note: 	children 0x3c60958 0x3c609d8
nbody.c:184:14: note: node 0x3c60958 (max_nunits=2, refcnt=1) vector(2) float
nbody.c:184:14: note: op template: _3 = *_2.vx;
nbody.c:184:14: note: 	stmt 0 _3 = *_2.vx;
nbody.c:184:14: note: 	stmt 1 _7 = *_2.vy;
nbody.c:184:14: note: node 0x3c609d8 (max_nunits=2, refcnt=1) vector(2) float
nbody.c:184:14: note: op template: _5 = fx.4_4 * dt_39(D);
nbody.c:184:14: note: 	stmt 0 _5 = fx.4_4 * dt_39(D);
nbody.c:184:14: note: 	stmt 1 _9 = fy.5_8 * dt_39(D);
nbody.c:184:14: note: 	children 0x3c60ad8 0x3c60b58
nbody.c:184:14: note: node (external) 0x3c60ad8 (max_nunits=1, refcnt=1) vector(2) float
nbody.c:184:14: note: 	{ fx.4_4, fy.5_8 }
nbody.c:184:14: note: node (external) 0x3c60b58 (max_nunits=1, refcnt=1) vector(2) float
nbody.c:184:14: note: 	{ dt_39(D), dt_39(D) }
nbody.c:184:14: note: ------>vectorizing SLP node starting from: _3 = *_2.vx;
nbody.c:184:14: note: transform load. ncopies = 1
nbody.c:184:14: note: create vector_type-pointer variable to type: vector(2) float  vectorizing a pointer ref: *_2.vx
nbody.c:184:14: note: created vectp.125_83
nbody.c:184:14: note: add new stmt: vect__3.126_82 = MEM <vector(2) float> [(float *)vectp.125_83];
nbody.c:184:14: note: add new stmt: vectp.125_81 = vectp.125_83 + 4;
nbody.c:184:14: note: ------>vectorizing SLP node starting from: _5 = fx.4_4 * dt_39(D);
nbody.c:184:14: note: transform binary/unary operation.
nbody.c:184:14: note: add new stmt: vect__5.127_78 = _80 * _79;
nbody.c:184:14: note: ------>vectorizing SLP node starting from: _6 = _3 + _5;
nbody.c:184:14: note: vect_is_simple_use: operand *_2.vx, type of def: internal
nbody.c:184:14: note: vect_is_simple_use: operand fx.4_4 * dt_39(D), type of def: internal
nbody.c:184:14: note: transform binary/unary operation.
nbody.c:184:14: note: add new stmt: vect__6.128_77 = vect__3.126_82 + vect__5.127_78;
nbody.c:184:14: note: ------>vectorizing SLP node starting from: *_2.vx = _6;
nbody.c:184:14: note: vect_is_simple_use: operand _3 + _5, type of def: internal
nbody.c:184:14: note: vect_is_simple_use: operand _7 + _9, type of def: internal
nbody.c:184:14: note: transform store. ncopies = 1
nbody.c:184:14: note: create vector_type-pointer variable to type: vector(2) float  vectorizing a pointer ref: *_2.vx
nbody.c:184:14: note: created vectp.130_76
nbody.c:184:14: note: add new stmt: MEM <vector(2) float> [(float *)vectp.130_76] = vect__6.128_77;
nbody.c:184:14: note: vectorizing stmts using SLP.
nbody.c:184:14: optimized: basic block part vectorized using 32 byte vectors
nbody.c:184:14: note: Vectorizing SLP tree:
nbody.c:184:14: note: node 0x3c60c58 (max_nunits=2, refcnt=1) vector(2) float
nbody.c:184:14: note: op template: *_16.x = _20;
nbody.c:184:14: note: 	stmt 0 *_16.x = _20;
nbody.c:184:14: note: 	stmt 1 *_16.y = _24;
nbody.c:184:14: note: 	children 0x3c60cd8
nbody.c:184:14: note: node 0x3c60cd8 (max_nunits=2, refcnt=1) vector(2) float
nbody.c:184:14: note: op template: _20 = _17 + _19;
nbody.c:184:14: note: 	stmt 0 _20 = _17 + _19;
nbody.c:184:14: note: 	stmt 1 _24 = _21 + _23;
nbody.c:184:14: note: 	children 0x3c60d58 0x3c60dd8
nbody.c:184:14: note: node 0x3c60d58 (max_nunits=2, refcnt=1) vector(2) float
nbody.c:184:14: note: op template: _17 = *_16.x;
nbody.c:184:14: note: 	stmt 0 _17 = *_16.x;
nbody.c:184:14: note: 	stmt 1 _21 = *_16.y;
nbody.c:184:14: note: node 0x3c60dd8 (max_nunits=2, refcnt=1) vector(2) float
nbody.c:184:14: note: op template: _19 = _18 * dt_39(D);
nbody.c:184:14: note: 	stmt 0 _19 = _18 * dt_39(D);
nbody.c:184:14: note: 	stmt 1 _23 = _22 * dt_39(D);
nbody.c:184:14: note: 	children 0x3c60e58 0x3c60ed8
nbody.c:184:14: note: node 0x3c60e58 (max_nunits=2, refcnt=1) vector(2) float
nbody.c:184:14: note: op template: _18 = *_16.vx;
nbody.c:184:14: note: 	stmt 0 _18 = *_16.vx;
nbody.c:184:14: note: 	stmt 1 _22 = *_16.vy;
nbody.c:184:14: note: node (external) 0x3c60ed8 (max_nunits=1, refcnt=1) vector(2) float
nbody.c:184:14: note: 	{ dt_39(D), dt_39(D) }
nbody.c:184:14: note: ------>vectorizing SLP node starting from: _17 = *_16.x;
nbody.c:184:14: note: transform load. ncopies = 1
nbody.c:184:14: note: create vector_type-pointer variable to type: vector(2) float  vectorizing a pointer ref: *_16.x
nbody.c:184:14: note: created vectp.132_74
nbody.c:184:14: note: add new stmt: vect__17.133_73 = MEM <vector(2) float> [(float *)vectp.132_74];
nbody.c:184:14: note: add new stmt: vectp.132_72 = vectp.132_74 + 16;
nbody.c:184:14: note: ------>vectorizing SLP node starting from: _18 = *_16.vx;
nbody.c:184:14: note: transform load. ncopies = 1
nbody.c:184:14: note: create vector_type-pointer variable to type: vector(2) float  vectorizing a pointer ref: *_16.vx
nbody.c:184:14: note: created vectp.135_71
nbody.c:184:14: note: add new stmt: vect__18.136_70 = MEM <vector(2) float> [(float *)vectp.135_71];
nbody.c:184:14: note: add new stmt: vectp.135_69 = vectp.135_71 + 16;
nbody.c:184:14: note: ------>vectorizing SLP node starting from: _19 = _18 * dt_39(D);
nbody.c:184:14: note: vect_is_simple_use: operand *_16.vx, type of def: internal
nbody.c:184:14: note: transform binary/unary operation.
nbody.c:184:14: note: add new stmt: vect__19.137_67 = vect__18.136_70 * _68;
nbody.c:184:14: note: ------>vectorizing SLP node starting from: _20 = _17 + _19;
nbody.c:184:14: note: vect_is_simple_use: operand *_16.x, type of def: internal
nbody.c:184:14: note: vect_is_simple_use: operand _18 * dt_39(D), type of def: internal
nbody.c:184:14: note: transform binary/unary operation.
nbody.c:184:14: note: add new stmt: vect__20.138_64 = vect__17.133_73 + vect__19.137_67;
nbody.c:184:14: note: extracting lane for live stmt _20 = _17 + _19;
nbody.c:184:14: note: extracting lane for live stmt _24 = _21 + _23;
nbody.c:184:14: note: ------>vectorizing SLP node starting from: *_16.x = _20;
nbody.c:184:14: note: vect_is_simple_use: operand _17 + _19, type of def: internal
nbody.c:184:14: note: vect_is_simple_use: operand _21 + _23, type of def: internal
nbody.c:184:14: note: transform store. ncopies = 1
nbody.c:184:14: note: create vector_type-pointer variable to type: vector(2) float  vectorizing a pointer ref: *_16.x
nbody.c:184:14: note: created vectp.140_58
nbody.c:184:14: note: add new stmt: MEM <vector(2) float> [(float *)vectp.140_58] = vect__20.138_64;
nbody.c:184:14: note: vectorizing stmts using SLP.
nbody.c:184:14: optimized: basic block part vectorized using 32 byte vectors
nbody.c:184:14: note: ***** The result for vector mode V32QI would be the same
BB 4 is always executed in loop 2
BB 3 is always executed in loop 1
loop 2's coldest_outermost_loop is 2, hotter_than_inner_loop is NULL
loop 1's coldest_outermost_loop is 1, hotter_than_inner_loop is NULL
nbody.c:182:21: note: considering unrolling loop 2 at BB 6
considering unrolling loop with constant number of iterations
considering unrolling loop with runtime-computable number of iterations
nbody.c:169:23: note: considering unrolling loop 1 at BB 4
considering unrolling loop with constant number of iterations
considering unrolling loop with runtime-computable number of iterations
nbody.c:267:11: missed: statement clobbers memory: drate_83 = sqrt (_32);
BB 5 is always executed in loop 1
loop 1's coldest_outermost_loop is 1, hotter_than_inner_loop is NULL
nbody.c:230:25: missed: statement clobbers memory: start_65 = omp_get_wtime ();
nbody.c:227:21: missed: couldn't vectorize loop
nbody.c:227:21: missed: not vectorized: control flow in loop.
nbody.c:192:5: note: vectorized 0 loops in function.
nbody.c:230:25: missed: statement clobbers memory: start_65 = omp_get_wtime ();
/usr/include/stdlib.h:495:10: missed: statement clobbers memory: _76 = strtoll (_1, 0B, 10);
nbody.c:211:28: missed: statement clobbers memory: p_46 = aligned_alloc (32, _2);
nbody.c:213:3: missed: statement clobbers memory: init (p_46, iftmp.7_38);
nbody.c:215:3: missed: statement clobbers memory: __builtin_puts (&"not done"[0]);
nbody.c:216:16: missed: statement clobbers memory: root_50 = createTree (p_46, iftmp.7_38);
nbody.c:217:3: missed: statement clobbers memory: __builtin_puts (&"done "[0]);
nbody.c:221:3: missed: statement clobbers memory: printf ("\n\x1b[1mTotal memory size:\x1b[0m %llu B, %llu KiB, %llu MiB\n\n", _2, _4, _3);
nbody.c:224:3: missed: statement clobbers memory: printf ("\x1b[1m%5s %10s %10s %8s\x1b[0m\n", "Step", "Time, s", "Interact/s", "GFLOP/s");
nbody.c:224:92: missed: statement clobbers memory: fflush (stdout.8_5);
nbody.c:230:25: missed: statement clobbers memory: start_65 = omp_get_wtime ();
nbody.c:232:7: missed: statement clobbers memory: move_particles (p_46, root_50, 9.99999977648258209228515625e-3, iftmp.7_38);
nbody.c:234:23: missed: statement clobbers memory: end_68 = omp_get_wtime ();
nbody.c:253:7: missed: statement clobbers memory: printf ("%5llu %10.3e %10.3e %8.1f %s\n", i_89, _25, _28, _26, iftmp.9_39);
nbody.c:260:7: missed: statement clobbers memory: fflush (stdout.10_29);
nbody.c:267:11: missed: statement clobbers memory: drate_83 = sqrt (_32);
nbody.c:269:3: missed: statement clobbers memory: __builtin_puts (&"-----------------------------------------------------"[0]);
nbody.c:270:3: missed: statement clobbers memory: printf ("\x1b[1m%s %4s \x1b[42m%10.1lf +- %.1lf GFLOP/s\x1b[0m\n", "Average performance:", "", rate_56, drate_84);
nbody.c:272:3: missed: statement clobbers memory: __builtin_puts (&"-----------------------------------------------------"[0]);
nbody.c:275:3: missed: statement clobbers memory: free (p_46);
nbody.c:276:3: missed: statement clobbers memory: free (root_50);
nbody.c:276:3: note: ***** Analysis failed with vector mode V4DI
nbody.c:276:3: note: ***** Skipping vector mode V32QI, which would repeat the analysis for V4DI
BB 5 is always executed in loop 1
loop 1's coldest_outermost_loop is 1, hotter_than_inner_loop is NULL
nbody.c:227:21: note: considering unrolling loop 1 at BB 5
considering unrolling loop with constant number of iterations
considering unrolling loop with runtime-computable number of iterations
